% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

% This is an Icelandic translation/adaptation of the orginal book by Allen B. Downey

\chapter{Meira um strúktúra}
\label{time}
\index{struct}

\section{Time}
\index{struct!Time}
\index{Time}

Í þeim tilgangi að sýna annað dæmi um strúktur munum við nú skilgreina tag með nafnið {\tt Time} sem notað er til að halda utan um tíma innan dags.
Tími samanstendur af klukkustund (hour), mínúta (minute) og sekúnda (second) þannig að þetta munu verða tilvikabreytur strúktúrsins.

Fyrsta skrefið er þá að ákveða hvert tag sérhverrar tilvikabreytu á að vera.
Það virðist ljóst að {\tt hour} og {\tt minute} ætti að vera heiltölur.
Til að hafa þetta áhugaverðara þá skulum við láta {\tt second} vera {\tt double} þannig að við getum haldið utan um brot af sekúndu.

Svona lítur þá strúktúrinn okkar út: 

\begin{verbatim}
struct Time {
  int hour, minute;
  double second;
};
\end{verbatim}
%
Við getum þá búið til {\tt Time} hlut á venjulegan hátt: 

\begin{verbatim}
  Time time = { 11, 59, 3.14159 };
\end{verbatim}
%
Stöðuritið fyrir þennan hlut lítur svona út:

\vspace{0.1in}
\centerline{\epsfig{figure=time.eps}}
\vspace{0.1in}

Orðið ``tilvik'' (e. instance) er stundum notað þegar við tölum um hluti (e. objects) vegna þess að sérhver hlutur er tilvik af einhverju tagi.
Ástæðan fyrir því að tilvikabreytur bera það nafn er að sérhvert tilvik af einhverju tagi eiga sér afrit af tilvikabreytum þess tags.

\section{{\tt printTime}}
\label{printobject}
\index{úttak}
\index{setning!úttak}
\index{hlutur!úttak}

Þegar við skilgreinum nýtt tag þá er góð regla að skrifa fall sem skrifar út tilvikabreyturnar á læsilegan hátt.
Dæmi:

\begin{verbatim}
void printTime (Time& t) {
  cout << t.hour << ":" << t.minute << ":" << t.second << endl;
}
\end{verbatim}
%
Ef við sendum inn {\tt time} sem viðfang í þetta fall þá er úttakið {\tt 11:59:3.14159}.

\begin{verbatim}
#include <iostream>

using namespace std;

struct Time {
  int hour, minute;
  double second;
};


void printTime (Time& t) {
  cout << t.hour << ":" << t.minute << ":" << t.second << endl;
  cout << "Time is " << t.hour << " hour " << t.minute << " minutes " << t.second << "  seconds  "<<endl;
}


int main ()
{
 Time time = { 11, 59, 3.14159 };
 printTime(time);
 
 return 0;
}
\end{verbatim}
%

\section{Föll fyrir hluti}
\label{objectops}
\index{hlutur}
\index{föll!fyrir hluti}

Í næstu köflum mun ég sýna dæmi um nokkur möguleg skil (e. interfaces) fyrir föll sem vinna með hluti.
Þú mun hafa val um nokkur möguleg skil fyrir tilteknar aðgerðir þannig að þú ættir að meta kosti og galla sérhvers möguleika:

\begin{description}

\item[hreint fall (e. pure function):]  Tekur hlut og/eða grunntag sem viðföng en breytir ekki hlutnum.
Skilagildið er annaðhvort grunntag eða nýr hlutur sem búinn er til í fallinu. 

\item[breytir (e. modifier):]  Tekur hluti sem viðföng og breytir sumum eða öllum þeirra.  Skilar oft void. \index{void}

\item[fyllir (e. fill-in function):]  Eitt af viðföngunum er ``tómur'' hlutur sem fallið fyllir inn í.
Tæknilega séð er þetta þá í raun tegund af breyti. 

\end{description}

\section{Hrein föll}
\index{hreint fall}
\index{fall}
\index{fall!hreint}

Fall er sagt vera hreint ef skilagildi þess er eingöngu háð viðföngunum og að það hafi ekki neinar aukaverkanir (e. side effects)
eins og að breyta viðfangi eða skrifa út eitthvað.
Það eina sem gerist þegar kallað er á hreint fall er að skilagildi kemur til baka.

Eitt dæmi um hreint fall er {\tt after} sem ber saman tvo {\tt Time} hluti og skilar {\tt bool} sem gefur til kynna hvort fyrsta viðfangið komi á eftir því seinna (tímalega séð):

\begin{verbatim}
bool after (Time& time1, Time& time2) {
  if (time1.hour > time2.hour) return true;
  if (time1.hour < time2.hour) return false;

  if (time1.minute > time2.minute) return true;
  if (time1.minute < time2.minute) return false;

  if (time1.second > time2.second) return true;
  return false;
}
\end{verbatim}
%
Hvert er skilagildi þessa falls ef tímarnir tveir eru jafnir?
Finnst þér það vera viðeigandi skilagildi fyrir þetta fall?
Ef þú værir að skjala þetta fall, myndir þú nefna þetta tilfelli sérstaklega?

Annað dæmi er {\tt addTime} sem reiknar summuna af tveimur tímasetningum.
Ef tíminn er t.d. {\tt 9:14:30} og brauðgerðin þín tekur 3 klukkustundir og 35 mínútur þá gætir þú notað {\tt addTime} til að finna út hvenær brauðið verður tilbúið.

Hér eru drög, sem eru reyndar ekki alveg rétt, af þessu falli::

\begin{verbatim}
Time addTime (Time& t1, Time& t2) {
  Time sum;
  sum.hour = t1.hour + t2.hour;
  sum.minute = t1.minute + t2.minute;
  sum.second = t1.second + t2.second;
  return sum;
}
\end{verbatim}
%
Hér er dæmi um hvernig hægt er að nota þetta fall.
Ef {\tt currentTime} inniheldur núverandi tíma og {\tt breadTime} inniheldur tímann sem tekur að baka brauðið þá getur þú notað {\tt addTime} til að reikna út hvenær brauðið verður tilbúið.

\begin{verbatim}
  Time currentTime = { 9, 14, 30.0 };
  Time breadTime = { 3, 35, 0.0 };
  Time doneTime = addTime (currentTime, breadTime);
  printTime (doneTime);
\end{verbatim}
%
Úttak þessa forrits er {\tt 12:49:30} sem er rétt.
Á hinn bóginn eru tilvik þar sem niðurstaðan er ekki rétt.
Getur þú fundið dæmi um þess konar tilvik?

Vandamálið er að þetta fall ræður ekki við þau tilvik þar sem summa sekúndna eða mínútna er stærri en 60.
Þegar það gerirst þá þurfum við að ``færa'' auka sekúndur yfir í mínútudálkinn eða auka mínútur yfir í klukkustundadálkinn.

Hér er önnur, nú rétt, útgáfa af fallinu:

\begin{verbatim}
Time addTime (Time& t1, Time& t2) {
  Time sum;
  sum.hour = t1.hour + t2.hour;
  sum.minute = t1.minute + t2.minute;
  sum.second = t1.second + t2.second;

  if (sum.second >= 60.0) {
    sum.second -= 60.0;
    sum.minute += 1;
  }
  if (sum.minute >= 60) {
    sum.minute -= 60;
    sum.hour += 1;
  }
  return sum;
}
\end{verbatim}
%
Þó svo að þessi útgáfa sé rétt þá er hún orðin dálítið löng.
Ég mun síðar leggja til aðra lausnaraðferð sem er mun styttri.

\index{increment}
\index{decrement}
\index{auki}
\index{frádrag}
\index{virki!auki}
\index{virki!frádrag}

Kóðinn að ofan sýnir dæmi um tvo virkja sem við höfum ekki séð áður, {\tt +=}og {\tt -=}.
Þessir virkjar eru notaðir sem samþjöppuð leið til að hækka eða lækka breytur.
Setningin {\tt sum.second -= 60.0;} er t.d. jafngild setningunni {\tt sum.second = sum.second - 60;}

\section{{\tt const} leppar}

Þú hefur væntanlega tekið eftir því að viðföngin fyrir {\tt after}
og {\tt addTime} eru send með tilvísun (e. by reference).
Þar sem um er að ræða hrein föll þá breyta þau ekki viðföngunum og því hefði ég alveg eins getað sent þau sem gildi (e. by value).

Kosturinn við að senda viðföng sem gildi er að fallið sem kallað er á og sá sem kallar eru hjúpuð á viðeigandi hátt -- breyting í öðrum þeirra getur ekki leitt til breytingar í hinum, nema í tengslum við skilagildið.

Á hinn bóginn er yfirleitt skilvirkara að senda viðföng með tilvísun vegna þess að þá þarf ekki að afrita nein gildi úr viðföngunum yfir í leppana.
Svo vill líka til að í C++ inniheldur eiginleika sem kallaður er {\tt const} og gerir það að verkum að það er jafn öruggt að senda tilvísunarviðföng eins og gildisviðföng.

Ef þú skrifar fall og ætlar ekki að breyta viðfangi þá getur þú skilgreint leppinn sem {\bf constant reference parameter}.
Málskipanin lítur svona út:

\begin{verbatim}
void printTime (const Time& time) ...
Time addTime (const Time& t1, const Time& t2) ...
\end{verbatim}
%
Hér sýni ég aðeins fyrstu línuna í föllunum.
Ef þú lætur þýðandann vita að þú ætlir ekki að breyta viðfangi í falli þá getur hann minnt þig á það!
Ef þú reynir að breyta viðfangi þá mun þýðandinn kvarta.

\index{keyrsluvilla}
\index{villa!við keyrslu}

\section{Breytir}
\index{modifier}
\index{fall!breytir}

Auðvitað vill svo til stundum að þú vilt einmitt breyta viðfangi.  Fall sem gerir það eru kallað breytir (e. modifier).

Skoðum fallið {\tt increment} sem dæmi um breyti en það bætir tilteknum fjölda sekúndna við {\tt Time} hlut.
Gróf drög fyrir þetta fall gæti litið svona út:

\begin{verbatim}
void increment (Time& time, double secs) {
  time.second += secs;

  if (time.second >= 60.0) {
    time.second -= 60.0;
    time.minute += 1;
  }
  if (time.minute >= 60) {
    time.minute -= 60;
    time.hour += 1;
  }
}
\end{verbatim}
%
Fyrsta línan framkvæmir grunnaðgerð en það sem á eftir kemur sér um sérstök tilfelli, eins og við sáum áður.

Er þetta fall rétt? Hvað gerist ef leppurinn {\tt secs} er mikið stærri en 60?
Í því tilfelli er ekki nóg að draga 60 frá einu sinni -- við þurfum að gera það þangað til {\tt second} er lægra en 60.

Við getum gert það með því að skipta {\tt if} setningum út fyrir {\tt while} setningar:

\begin{verbatim}
void increment (Time& time, double secs) {
  time.second += secs;

  while (time.second >= 60.0) {
    time.second -= 60.0;
    time.minute += 1;
  }
  while (time.minute >= 60) {
    time.minute -= 60;
    time.hour += 1;
  }
}
\end{verbatim}
%
Þessi lausn er rétt en ekki mjög skilvirk.
Getur þú séð fyrir þér lausn sem þarfnast ekki ítrunar?

\section{Fill-in functions}
\index{fill-in function}
\index{function!fill-in}

Occasionally you will see functions like {\tt addTime} written
with a different interface (different arguments and return values).
Instead of creating a new object every time {\tt addTime} is
called, we could require the caller to provide an ``empty''
object where {\tt addTime} can store the result.  Compare
the following with the previous version:

\begin{verbatim}
void addTimeFill (const Time& t1, const Time& t2, Time& sum) {
  sum.hour = t1.hour + t2.hour;
  sum.minute = t1.minute + t2.minute;
  sum.second = t1.second + t2.second;

  if (sum.second >= 60.0) {
    sum.second -= 60.0;
    sum.minute += 1;
  }
  if (sum.minute >= 60) {
    sum.minute -= 60;
    sum.hour += 1;
  }
}
\end{verbatim}
%
One advantage of this approach is that the caller has the option of
reusing the same object repeatedly to perform a series of additions.
This can be slightly more efficient, although it can be confusing
enough to cause subtle errors.  For the vast majority of programming,
it is worth a spending a little run time to avoid a lot of debugging
time.

Notice that the first two parameters can be declared {\tt const},
but the third cannot.

\section{Which is best?}
\index{programming style}

Anything that can be done with modifiers and fill-in functions can also
be done with pure functions.  In fact, there are programming
languages, called {\bf functional} programming languages, that only
allow pure functions.  Some programmers believe that programs that use
pure functions are faster to develop and less error-prone than
programs that use modifiers.  Nevertheless, there are times when
modifiers are convenient, and cases where functional programs
are less efficient.

In general, I recommend that you write pure functions whenever
it is reasonable to do so, and resort to modifiers only if there
is a compelling advantage.  This approach might be called a
functional programming style.

\section{Incremental development versus planning}
\index{incremental development}
\index{prototyping}
\index{program development!incremental}
\index{program development!planning}

In this chapter I have demonstrated an approach to program
development I refer to as {\bf rapid prototyping with iterative
improvement}.  In each case, I wrote a rough draft (or prototype)
that performed the basic calculation, and then tested it on
a few cases, correcting flaws as I found them.

Although this approach can be effective, it can lead to code
that is unnecessarily complicated---since it deals with many
special cases---and unreliable---since it is hard to know if
you have found all the errors.

An alternative is high-level planning, in which a little insight
into the problem can make the programming much easier.  In
this case the insight is that a {\tt Time} is really a three-digit
number in base 60!  The {\tt second} is the ``ones column,''
the {\tt minute} is the ``60's column'', and the {\tt hour}
is the ``3600's column.''

When we wrote {\tt addTime} and {\tt increment}, we were effectively
doing addition in base 60, which is why we had to ``carry'' from one
column to the next.

\index{arithmetic!base 60}
\index{arithmetic!floating-point}

Thus an alternate approach to the whole problem is to convert
{\tt Time}s into {\tt double}s and take advantage of the fact that
the computer already knows how to do arithmetic with {\tt double}s.
Here is a function that converts a {\tt Time} into a {\tt double}:

\begin{verbatim}
double convertToSeconds (const Time& t) {
  int minutes = t.hour * 60 + t.minute;
  double seconds = minutes * 60 + t.second;
  return seconds;
}
\end{verbatim}
%
Now all we need is a way to convert from a {\tt double}
to a {\tt Time} object:

\begin{verbatim}
Time makeTime (double secs) {
  Time time;
  time.hour = int (secs / 3600.0);
  secs -= time.hour * 3600.0;
  time.minute = int (secs / 60.0);
  secs -= time.minute * 60;
  time.second = secs;
  return time;
}
\end{verbatim}
%
You might have to think a bit to convince yourself that the technique
I am using to convert from one base to another is correct.  Assuming
you are convinced, we can use these functions to rewrite {\tt addTime}:

\begin{verbatim}
Time addTime (const Time& t1, const Time& t2) {
  double seconds = convertToSeconds (t1) + convertToSeconds (t2);
  return makeTime (seconds);
}
\end{verbatim}
%
This is much shorter than the original version, and it is much easier
to demonstrate that it is correct (assuming, as usual, that the
functions it calls are correct).  As an exercise, rewrite {\tt
increment} the same way.


\section{Generalization}
\index{generalization}

In some ways converting from base 60 to base 10 and back is
harder than just dealing with times.  Base conversion is more
abstract; our intuition for dealing with times is better.

But if we have the insight to treat times as base 60 numbers,
and make the investment of writing the conversion functions
({\tt convertToSeconds} and {\tt makeTime}), we get
a program that is shorter, easier to read and debug, and more
reliable.

It is also easier to add more features later.  For example, imagine
subtracting two {\tt Time}s to find the duration between them.  The
naive approach would be to implement subtraction with
borrowing.  Using the conversion functions would be easier and more
likely to be correct.

Ironically, sometimes making a problem harder (more general)
makes is easier (fewer special cases, fewer opportunities for error).

\section{Algorithms}
\label{algorithm}
\index{algorithm}

When you write a general solution for a class of problems, as opposed
to a specific solution to a single problem, you have written an {\bf
algorithm}.  I mentioned this word in Chapter 1, but did not define it
carefully.  It is not easy to define, so I will try a couple of
approaches.

First, consider something that is not an algorithm.
When you learned to multiply single-digit numbers, you probably
memorized the multiplication table.  In effect, you memorized 100
specific solutions.  That kind of knowledge is not really algorithmic.

But if you were ``lazy,'' you probably cheated by learning a few
tricks.  For example, to find the product of $n$ and 9, you can write
$n-1$ as the first digit and $10-n$ as the second digit.  This trick
is a general solution for multiplying any single-digit number by 9.
That's an algorithm!

Similarly, the techniques you learned for addition with carrying,
subtraction with borrowing, and long division are all algorithms.  One
of the characteristics of algorithms is that they do not require any
intelligence to carry out.  They are mechanical processes in which
each step follows from the last according to a simple set of rules.

In my opinion, it is embarrassing that humans spend so much time in
school learning to execute algorithms that, quite literally, require
no intelligence.

On the other hand, the process of designing algorithms is interesting,
intellectually challenging, and a central part of what we call
programming.

Some of the things that people do naturally, without difficulty
or conscious thought, are the most difficult to express
algorithmically.  Understanding natural language is a good
example.  We all do it, but so far no one has been able to
explain {\em how} we do it, at least not in the form of an
algorithm.

Later in this book, you will have the opportunity to design
simple algorithms for a variety of problems.  If you take
the next class in the Computer Science sequence, Data Structures,
you will see some of the most interesting, clever, and
useful algorithms computer science has produced.

\section{Glossary}

\begin{description}

\item[instance:]  An example from a category.  My cat is an
instance of the category ``feline things.''  Every object is
an instance of some type.

\item[instance variable:]  One of the named data items that make
up an structure.  Each structure has its own copy of
the instance variables for its type.

\item[constant reference parameter:]  A parameter that is passed
by reference but that cannot be modified.

\item[pure function:]  A function whose result depends only on its
parameters, and that has so effects other than returning
a value.

\item[functional programming style:]  A style of program design
in which the majority of functions are pure.

\item[modifier:]  A function that changes one or more of the objects
it receives as parameters, and usually returns {\tt void}.

\item[fill-in function:]  A function that takes an ``empty''
object as a parameter and fills it its instance variables instead
of generating a return value.

\item[algorithm:]  A set of instructions for solving a class of
problems by a mechanical, unintelligent process.

\index{instance}
\index{instance variable}
\index{pure function}
\index{functional programming}
\index{modifier}
\index{algorithm}

\end{description}

