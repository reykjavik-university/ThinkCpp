% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

% This is an Icelandic translation/adaptation of the orginal book by Allen B. Downey

\chapter{Vektorar}
\label{vectors}
\index{vektor}
\index{tag!vektor}

{\bf Vektor} (e. vector) er mengi gilda þar sem hvert þeirra er auðkennt með tölu sem kölluð er vísir (e. index).
Strengur ({\tt string}) er svipaður og vektor þar sem hann samanstendur af mengi af stöfum sem hægt er að vísa í með tölu.
Vektorar í C++ eru hentugir í notkun því þeir geta geymt ýmis konar gögn, þ.m.t. grunntög eins og {\tt int} og {\tt double}, 
eða tög sem skilgreind eru af notanda, eins og {\tt Point} og {\tt Time}.

Tagið {\tt vector} er skilgreint í C++ ``Standard Template Library'' (STL).
Til að nota það þarf að taka inn (e. include) hausaskrána {\tt vector} -- hvernig það er gert er háð þínu forritunarumhverfi.

Þú getur búið til vektor á sama hátt og þú býrð til breytu af hvaða öðru tagi:

\begin{verbatim}
  vector<int> count;
  vector<double> doubleVector;
\end{verbatim}
%
Tagið sem vektorinn mun geyma kemur fram í hornsvigunum (e. angle brackets) ({\tt <} og {\tt >}).
Fyrri línan býr til vektor af heiltölum með nafnið {\tt count}; seinni línan býr til vektor af {\tt double}.
Þrátt fyrir að þessar setningar séu löglegar þá eru þær ekki mjög gagnlegar vegna þess að þær búa til vektora sem hafa engin stök (stærð þeirra er núll).
Það er því mun algengara að skilgreina stærð vektorsins innan sviga: 

\begin{verbatim}
  vector<int> count (4);
\end{verbatim}
%
Málskipanin er hér dálítið skrýtin því hún lítur út eins og samsetning breytuyfirlýsingar og fallakalls.
Það er reyndar nákvæmlega það sem hún er!
Fallið sem við erum að kalla á er svokallaður smiður í {\tt vector} klasanum.
{\bf Smiður} (e. constructor) er sérstakt fall sem býr til nýtt tilvik og upphafsstillir tilvikabreytur þess.
Í þessu tilviki tekur smiðurinn eitt viðfang sem er stærð vektorsins.

\index{smiður}

Eftirfarandi mynd sýnir hvernig vektorar eru táknaðir á stöðuritum:

\vspace{0.1in}
\centerline{\epsfig{figure=vector.eps}}
\vspace{0.1in}

Stóru tölurnar innan í boxunum eru {\bf stök} (e. elements) vektorsins. 
Litlu tölurnar fyrir utan boxin eru vísarnir (e. indices) sem notaðir eru til að einkenna sérhvert box.
Stök vektors eru ekki upphafsstillt þegar nýr vektor er búinn til.
Þau gætu í raun innihaldið hvaða gildi sem er.

Það er til annar smiður fyrir {\tt vector} sem tekur tvö viðföng; seinna viðfangið er ``upphafsstillingargildi'', þ.e. gildið sem sérhvert stak vektorsins fær í upphafi.

\begin{verbatim}
  vector<int> count (4, 0);
\end{verbatim}
%
Þessi setning býr til vektor með fjórum stökum og upphafsstillir öll stökin með núlli.

\section{Aðgangur að stökum}
\index{stak}
\index{vektor!stak}

Virkjann {\tt []} er hægt að nota til að lesa og skrifa stök vektors á sambærilegan hátt og gert er með strengi.
Vísarnir byrja í núlli, þannig að {\tt count[0]} vísar til ``núllta'' staks vektorsins {\tt count} og
{\tt count[1]} vísar til ``fyrsta'' staksins.
Þú getur notað virkjann {\tt []} hvar sem er í segð:

\begin{verbatim}
  count[0] = 7;
  count[1] = count[0] * 2;
  count[2]++;
  count[3] -= 60;
\end{verbatim}
%
Allar þessar setningar eru löglegar og áhrif þessa kóða á vektorinn er: 

\vspace{0.1in}
\centerline{\epsfig{figure=vector2.eps}}
\vspace{0.1in}

Ekkert stak er með vísinn 4 þar sem stök þessa vektors eru númeruð frá 0 to 3.
Það er algeng villa að reyna að vísa ``út fyrir'' vektor og það veldur keyrsluvillu.
Í því tilfelli skrifar forritið út villuskilaboð eins og ``Illegal vector index'', og hættir síðan keyrslu.

\index{keyrsluvilla}
\index{vísir}
\index{segð}

Þú getur notað hvaða segð sem er sem vísi svo framarlega sem hún hefur tagið {\tt int}.
Eins algengast leiðin til að vísa í stök vektors er að nota lykkjubreytu (e. loop variable).
Dæmi:

\begin{verbatim}
  int i = 0;
  while (i < 4) {
    cout << count[i] << endl;
    i++;
  }
\end{verbatim}
%
Þessi {\tt while} lykkja ``hleypur'' frá 0 í 4.
Þegar lykkjubreytan {\tt i} fær gildið 4 þá verður skilyrðið {\tt false} og lykkjan hættir.
Meginmál lykkjunnar er því eingöngu keyrt þegar {\tt i} er 0, 1, 2 og 3.

\index{lykkja}
\index{lykkjubreyta}
\index{breyta!lykkja}

Í sérhverri ítrun lykkjunnar notum við {\tt i} sem vísi inn í vektorinn og skrifum út {\tt i}-ta stakið.
Þessi tegund af ``vektorrölti'' er mjög algeng enda vinna vektorar og lykkjur vel saman.

\section{Afritun vektora}
\index{vektor!afritun}

Það er til einn smiður í viðbót fyrir {\tt vector} sem kallaður ``afritatökusmiður'' (e. copy constructor)
vegna þess að hann tekur einn {\tt vector} sem viðfang og býr til nýjan vektor af sömu stærð og með sömu stök.

\begin{verbatim}
  vector<int> copy (count);
\end{verbatim}
%
Þrátt fyrir að þessi málskipan sé lögleg þá er hún sjaldan notuð fyrir vektorar því til er betri leið:

\begin{verbatim}
  vector<int> copy = count;
\end{verbatim}
%
Gildisveitingarvirkinn {\tt =} virkar fyrir vektorar á þann hátt sem ætla má.

\section{{\tt for} lykkjur}

Lykkjurnar sem við höfum skrifað hingað til eiga ýmislegt sameiginlegt.
Allar byrjar þær á því að upphafsstilla breytur; þær innihalda skilyrði sem er háð breytunni og meginmál lykkjunnar gerir eitthvað við breytuna, eins og að hækka hana. 

\index{lykkja!for}
\index{for}
\index{setning!for}

Þessi tegund af lykkju er svo algeng að það er til annars konar lykkjusetning, kölluð {\tt for}-setning, sem tjáir þetta á samþjappaðri hátt.
Málskipanin lítur svona út:

\begin{verbatim}
  for (INITIALIZER; CONDITION; INCREMENTOR) {
    BODY
  }
\end{verbatim}
%
Ofangreind setning er nákvæmlega jafngild þessu:

\begin{verbatim}
  INITIALIZER;
  while (CONDITION) {
    BODY
    INCREMENTOR
  }
\end{verbatim}
%
{\tt for}-setningin er aftur á móti gagnorðaðri og læsilegri því í henni eru allar lykkjusetningarnar á einum stað.
Dæmi:

\begin{verbatim}
  int i;
  for (i = 0; i < 4; i++) {
    cout << count[i] << endl;
  }
\end{verbatim}
%
er jafngilt:

\begin{verbatim}
  int i = 0;
  while (i < 4) {
    cout << count[i] << endl;
    i++;
  }
\end{verbatim}

\section{Stærð vektors}
\index{stærð!vektor}
\index{veckor!stærð}

Það eru margvísleg föll sem hægt er að keyra fyrir {\tt vector}.
Eitt af þeim er þó sérstaklega gagnlegt: {\tt size()}.
Þetta fall skilar stærð vektors, þ.e. fjölda staka.

Það er góð regla að nota þetta gildi sem efri mörk (e. upper bound) lykkju frekar heldur en einhvern fasta.
Þannig þarf ekki að breyta lykkjunni ef stærð vektorsins breytist.

\begin{verbatim}
  int i;
  for (i = 0; i < count.size(); i++) {
    cout << count[i] << endl;
  }
\end{verbatim}
%
Í síðasta skiptið sem meginmál lykkjunnar er keyrt er gildið á {\tt i} jafnt {\tt count.size() - 1}, sem er vísirinn á síðasta stakinu.
Þegar {\tt i} er jafnt {\tt count.size()} mun skilyrðið verða {\tt false} og meginmál lykkjunnar verður því ekki keyrt lengur.
Það er gott því annars myndi keyrsluvilla koma upp!
Taktu eftir því að kallað er á {\tt size()} fallið í hverri ítrun lykkjunnar.
Það að kalla á fall aftur og aftur hefur áhrif á keyrslutímann þannig að í raun væri betra að geyma stærð vektorsins í einhverri breytu með því að kalla á 
{\tt size()} áður en lykkjan hefst og nota síðan breytuna til að tékka á síðasta gildinu.
Þú ættir að æfa þig með því að prófa að gera þessa breytingu.

\section{Vektorföll}
\index{föll!vektor}
\index{vektor!föll}

Einn besti eiginleiki vektors er geta hans til að stækka eða minnka að þörf.
Eftir að vektor hefur verið búinn til þá er hægt að stækka hann eða minnka hvar sem er í forritinu.
Gerum t.d. ráð fyrir að við lesum inn tölur frá notanda inn í vektor þangað til notandi slær inn {\tt -1} en þá skrifum við tölurnar út.
Í svona tilviki vitum við ekki stærðina á vektornum fyrirfram.
Við þurfum því að geta bætt nýjum stökum við enda vektorsins um leið og notandinn slær inn ný gildi.
Við getum notað fallið {\tt push\_back()} í þessum tilgangi:

\begin{verbatim}
  #include<iostream>
  #include<vector>
  using namespace std;
  int main()
  {
    vector<int> values;
    int c,i,len;
    cin>>c;
    
    while(c != -1) {
      values.push_back(c);
      cin >> c;
    }
    len=values.size();
    for(i = 0; i < len; i++) {
      cout << values[i] << endl;
    }
  }

\end{verbatim}

\section{Slembitölur}
\label{random}
\label{pseudorandom}
\index{slembitala}
%\index{deterministic}
\index{löggengur}
%\index{nondeterministic}
\index{brigðgengur}

Flestar tölvur gera það sama í hvert sinn sem þær eru keyrðar með sama forritinu og eru kallaðar {\bf löggengar} (e. deterministic). 
Löggengni er yfirleitt kostur því við viljum jú að sömu útreikningar skili alltaf af sér sömu niðurstöðu.
Í sumum tilvikum gætum við viljað að tölvur væru óútreiknanlegar.  Tölvuleikir eru gott dæmi um þetta.

Það að gera forrit algerlega {\bf brigðgengt} (e. nondeterministic) er ekki auðvelt en það eru til leiðir til að láta það líta svo út.
Ein leið er að búa til ``pseudo'' slembitölur (e. random numbers) og nota þær til að stýra útkomunni úr forriti.
``Pseudo'' slembitölur eru ekki algerlega handahófskenndar í stærðfræðilegum skilningi en þær duga fyrir það sem við ætlum að gera.

Í hausaskránni {\tt cstdlib} (sem inniheldur ýmis konar ``standard library'' föll) er fallið {\tt random} skilgreint en það býr til ``pseudo'' slembitölur.

Skilagildið úr {\tt random} er heiltala á milli 0 og {\tt RAND\_MAX}
en {\tt RAND\_MAX} er stór tala (um það bil 2 milljarðar á minni tölvu) sem einnig er skilgreind í hausaskránni.
Í sérhvert sinn sem þú kallar á {\tt random} færðu nýja slembitölu.
Til að sjá dæmi um þetta skaltu keyra eftirfarandi lykkju:

\begin{verbatim}
#include <iostream>
#include <cstdlib>
using namespace std;

int main ()
{
  for (int i = 0; i < 4; i++) {
    int x = random ();
    cout << x << endl;
  }
  return 0;
}

  
\end{verbatim}
%
Ég fæ eftirfarandi úttak á minni vél: 

\begin{verbatim}
1804289383
846930886
1681692777
1714636915
\end{verbatim}
%
Þú færð væntanlega eitthvað annað, en þó svipað, á þinni tölvu.

Auðvitað viljum við ekki alltaf vinna með svona stórar heiltölur.
Það er algengara að búa til heiltölur á milli 0 og einhvers efri marks.
Einföld leið til að gera það er að nota ``modulus'' virkjann:
Dæmi:

\begin{verbatim}
  int x = random ();
  int y = x % upperBound;
\end{verbatim}
%
Þar sem {\tt y} er afgangurinn sem fæst með þvi að deila {\tt x} með {\tt upperBound} þá liggja gildin fyrir {\tt y} á bilinu 0 og {\tt upperBound - 1} (að báðum meðtöldum).
Hafðu í huga að {\tt y} er aldrei jafnt og {\tt upperBound}.

Það er einnig oft gagnlegt að búa til slembi kommutölur
Algeng leið til að gera það er að deila með {\tt RAND\_MAX}.
Dæmi:

\begin{verbatim}
  int x = random ();
  double y = double(x) / RAND_MAX;
\end{verbatim}
%
Þessi kóði gefur {\tt y} gildi slembikommutölu á milli 0.0 and 1.0 (að báðum meðtöldum).
Þú ættir núna að íhuga hvernig hægt er að búa til slembikommutölu á ákveðnu bili, t.d. á milli 100,0 og 200,0.

\section{Statistics}
\index{statistics}
\index{distribution}
\index{mean}

The numbers generated by {\tt random} are supposed to be distributed
uniformly.  That means that each value in the range should be
equally likely.  If we count the number of times each value appears,
it should be roughly the same for all values, provided that we
generate a large number of values.

In the next few sections, we will write programs that generate
a sequence of random numbers and check whether this property
holds true.

\section{Vector of random numbers}

The first step is to generate a large number of random values
and store them in a vector.  By ``large number,'' of course,
I mean 20.  It's always a good idea to start with a manageable
number, to help with debugging, and then increase it later.

The following function takes a single argument, the size of
the vector.  It allocates a new vector of {\tt int}s, 
and fills it with random values between 0 and {\tt upperBound-1}.

\begin{verbatim}
vector<int> randomVector (int n, int upperBound) {
  vector<int> vec (n);
  for (int i = 0; i<vec.size(); i++) {
    vec[i] = random () % upperBound;
  }
  return vec;
}
\end{verbatim}
%
The return type is {\tt vector<int>}, which means that
this function returns a vector of integers.
To test this function, it is convenient to have a function that
outputs the contents of a vector.

\begin{verbatim}
void printVector (const vector<int>& vec) {
  for (int i = 0; i<vec.size(); i++) {
    cout << vec[i] << " ";
  }
}
\end{verbatim}
%
Notice that it is legal to pass {\tt vector}s by reference.
In fact it is quite common, since it makes it unnecessary to
copy the vector.  Since {\tt printVector} does not modify the
vector, we declare the parameter {\tt const}.

The following code generates a vector and outputs it:

\begin{verbatim}
  int numValues = 20;
  int upperBound = 10;
  vector<int> vector = randomVector (numValues, upperBound);
  printVector (vector);
\end{verbatim}
%
On my machine the output is

\begin{verbatim}
3 6 7 5 3 5 6 2 9 1 2 7 0 9 3 6 0 6 2 6 
\end{verbatim}
%
which is pretty random-looking.  Your results may differ.

If these numbers are really random,
we expect each digit to appear the same number of times---twice
each.  In fact, the number 6 appears five times, and the numbers 4
and 8 never appear at all.

Do these results mean the values are not really uniform?  It's
hard to tell.  With so few values, the chances are slim
that we would get exactly what we expect.  But as the number
of values increases, the outcome should be more predictable.

To test this theory, we'll write some programs that count the
number of times each value appears, and then see what happens
when we increase {\tt numValues}.

\section{Counting}
\label{counting}
\index{traverse!counting}
\index{loop!counting}
\index{counter}

A good approach to problems like this is to think of simple functions
that are easy to write, and that might turn out to be useful.  Then
you can combine them into a solution.  This approach is sometimes
called {\bf bottom-up design}.  Of course, it is not easy to
know ahead of time which functions are likely to be useful, but as you
gain experience you will have a better idea.

\index{bottom-up design}
\index{program development!bottom-up}

Also, it is not always obvious what sort of things are easy to write,
but a good approach is to look for subproblems that fit a pattern you
have seen before.

\index{pattern!counter}

Back in Section~\ref{loopcount} we looked at a loop that traversed a
string and counted the number of times a given letter appeared.  You
can think of this program as an example of a pattern called ``traverse
and count.''  The elements of this pattern are:

\begin{itemize}

\item A set or container that can be traversed, like a string
or a vector.

\item A test that you can apply to each element in the container.

\item A counter that keeps track of how many elements pass
the test.

\end{itemize}

In this case, I have a function in mind called {\tt howMany} that
counts the number of elements in a vector that equal a given value.
The parameters are the vector and the integer value we are looking
for.  The return value is the number of times the value appears.

\begin{verbatim}
int howMany (const vector<int>& vec, int value) {
  int count = 0;
  for (int i=0; i< vec.size(); i++) {
    if (vec[i] == value) count++;
  }
  return count;
}
\end{verbatim}


\section{Checking the other values}

{\tt howMany} only counts the occurrences of a particular value, and
we are interested in seeing how many times each value appears.
We can solve that problem with a loop:

\begin{verbatim}
  int numValues = 20;
  int upperBound = 10;
  vector<int> vector = randomVector (numValues, upperBound);

  cout << "value\thowMany";

  for (int i = 0; i<upperBound; i++) {
    cout << i << '\t' << howMany (vector, i) << endl;
  }
\end{verbatim}
%
Notice that it is legal to declare a variable inside a {\tt for}
statement.  This syntax is sometimes convenient, but you should
be aware that a variable declared inside a loop only exists
inside the loop.  If you try to refer to {\tt i} later, you
will get a compiler error.

This code uses the loop variable as an argument to
{\tt howMany}, in order to check each value between 0 and 9,
in order.  The result is:

\begin{verbatim}
value   howMany
0       2
1       1
2       3
3       3
4       0
5       2
6       5
7       2
8       0
9       2
\end{verbatim}
%
Again, it is hard to tell if the digits are really appearing
equally often.  If we increase {\tt numValues} to 100,000 we
get the following:

\begin{verbatim}
value   howMany
0       10130
1       10072
2       9990
3       9842
4       10174
5       9930
6       10059
7       9954
8       9891
9       9958
\end{verbatim}
%
In each case, the number of appearances is within about 1\% of
the expected value (10,000), so we conclude that the random
numbers are probably uniform.

\section {A histogram}
\index{histogram}

It is often useful to take the data from the previous tables
and store them for later access, rather than just print them.
What we need is a way to store 10 integers.  We could create
10 integer variables with names like {\tt howManyOnes},
{\tt howManyTwos}, etc.  But that would require a lot of
typing, and it would be a real pain later if we decided to
change the range of values.

A better solution is to use a vector with size 10.  That
way we can create all ten storage locations at once and we
can access them using indices, rather than ten different names.
Here's how:

\begin{verbatim}
  int numValues = 100000;
  int upperBound = 10;
  vector<int> vector = randomVector (numValues, upperBound);
  vector<int> histogram (upperBound);

  for (int i = 0; i<upperBound; i++) {
    int count = howMany (vector, i);
    histogram[i] = count;
  }
\end{verbatim}
%
I called the vector {\bf histogram} because that's
a statistical term for a vector of numbers that counts the
number of appearances of a range of values.

\index{histogram}

The tricky thing here is that I am using the loop variable
in two different ways.  First, it is an argument to {\tt howMany},
specifying which value I am interested in.  Second, it is
an index into the histogram, specifying which location I should
store the result in.

\section{A single-pass solution}

Although this code works, it is not as efficient as it could
be.  Every time it calls {\tt howMany}, it traverses the
entire vector.  In this example we have to traverse the
vector ten times!

It would be better to make a single pass through the vector.
For each value in the vector we could find the corresponding
counter and increment it.  In other words, we can use the
value from the vector as an index into the histogram.  Here's
what that looks like:

\begin{verbatim}
  vector<int> histogram (upperBound, 0);

  for (int i = 0; i<numValues; i++) {
    int index = vector[i];
    histogram[index]++;
  }
\end{verbatim}
%
The first line initializes the elements of the histogram to
zeroes.  That way, when we use the increment
operator ({\tt ++}) inside the loop, we know we are starting from zero.
Forgetting to initialize counters is a common error.

As an exercise, encapsulate this code in a function called {\tt
histogram} that takes a vector and the range of values in the vector
(in this case 0 through 10), and that returns a histogram of the
values in the vector.

\section{Random seeds}
\index{seed}
\index{random}

If you have run the code in this chapter a few times, you might
have noticed that you are getting the same ``random'' values
every time.  That's not very random!

One of the properties of pseudorandom number generators is that
if they start from the same place they will generate
the same sequence of values.  The starting place is called
a {\bf seed}; by default, C++ uses
the same seed every time you run the program.

While you are debugging, it is often helpful to
see the same sequence over and over.  That way, when you make
a change to the program you can compare the output before and
after the change.

If you want to choose a different seed for the random number
generator, you can use the {\tt srand} function.  It takes
a single argument, which is an integer between 0 and {\tt RAND\_MAX}.

For many applications, like games, you want to see a different
random sequence every time the program runs.  A common way to
do that is to use a library function like {\tt gettimeofday}
to generate something reasonably unpredictable
and unrepeatable, like the number of milliseconds since the
last second tick, and use that number as a seed.  The details
of how to do that depend on your development environment.

\section{Glossary}

\begin{description}

\item[vector:]  A named collection of values, where all the
values have the same type, and each value is identified by
an index.

\item[element:]  One of the values in a vector.  The {\tt []}
operator selects elements of a vector.

\item[index:]  An integer variable or value used to indicate
an element of a vector.

\item[constructor:]  A special function that creates a new
object and initializes its instance variables.

\item[deterministic:]  A program that does the same thing every
time it is run.

\item[pseudorandom:]  A sequence of numbers that appear to be
random, but which are actually the product of a deterministic
computation.

\item[seed:]  A value used to initialize a random number sequence.
Using the same seed should yield the same sequence of values.

\item[bottom-up design:]  A method of program development that
starts by writing small, useful functions and then assembling
them into larger solutions.

\item[histogram:]  A vector of integers where each integer
counts the number of values that fall into a certain range.

\index{vector}
\index{element}
\index{index}
\index{constructor}
\index{deterministic}
\index{pseudorandom}
\index{seed}
\index{histogram}

\end{description}
