% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

% This is an Icelandic translation/adaptation of the orginal book by Allen B. Downey

\chapter{Strúktúrar}
\label{structs}
\index{struct}

%\section{Compound values}
\section{Samsett gildi}

Flest af þeim gagnatögum sem við höfum unnið með hingað til standa fyrir eitt tiltekið
gildi -- heiltölu, kommutölu og boole gildi.
Strengir eru öðruvísi að því leyti til að þeir eru settir saman úr smærri gildum, þ.e. stöfum.
Strengir eru því dæmi um {\bf samsett} gildi (e. compound type).

Við gætum þurft að meðhöndla samsett gildi sem einn tiltekinn hlut og við gætum þurft að komast í einstaka hluta (tilvikabreytur (e instance variables)) samsetta gildisins.
%This ambiguity is useful.

Það er einnig gagnlegt fyrir þig að geta búið til þín eigin samsett gildi.
C++ býður upp á tvær leiðir til að gera það: {\bf strúktúra} (e. structures) og {\bf klasa} (e. classes).
Við munum byrja á því að fjalla um strúktúra og förum síðan í klasa í kafla~\ref{class} (það er ekki mikill munur á milli þeirra.

\section{{\tt Point} hlutir}
\index{Point}
\index{struct!Point}

Við skulum skoða stærðfræðilegan punkt (eins og í hnitakerfi) sem dæmi um samsett gildi.
Punktur er í raun tvær tölur (hnit) sem við meðhöndlum sem einn tiltekinn hlut.
Í stærðfræði eru punktar oft skrifaðir innan sviga með kommu á milli hnitanna.
T.d. gefur $(0, 0)$ til kynna upphafspunkt (hnitamiðju) og $(x, y)$ stendur fyrir punkt sem er $x$ einingar til hægri og $y$ einingar upp miðað við upphafspunktinn.

Eðlileg leið til að tákna punkt í C++ er að nota tvær kommutölur, {\tt double}.
Spurningin er hins vegar hvernig hægt er að setja þessi tvö gildi saman í samsettan hlut eða strúktúr.
Það er hægt með því að nota {\tt struct} skilgreiningu:

\begin{verbatim}
struct Point {
  double x, y;
};  
\end{verbatim}
%
{\tt struct} skilgreining kemur yfirleitt fyrir utan fallaskilgreininga, í upphafi forrits (á eftir {\tt include} setningum).

Þessi skilgreining gefur til kynna að í strúktúrnum eru tvö stök (gildi), nefnd {\tt x} og {\tt y}.
Þessi stök eru kölluð {\bf tilvikabreytur} (e. instance variables), en ég mun skýra síðar hver ástæðan er fyrir því.

Það er algeng villa að gleyma semíkommunni í enda strúktúrskilgreiningar.
Það virðist skrýtið að setja semíkommu á eftir slaufusviga en þú venst því fljótt.

Þegar þú hefur skilgreint nýjan strúktúr þá getur þú búið til breytur af því tagi:

\begin{verbatim}
  Point blank;
  blank.x = 3.0;
  blank.y = 4.0;   
\end{verbatim}
%
Fyrsta línan er hefðbundin yfirlýsing á breytu: {\tt blank} er af taginu {\tt Point}.
Næstu tvær línur upphafsstilla tilvikabreytur strúktúrsins.
Hér er punktatáknun notuð á svipaðan hátt og þegar kallað er á fall sem tilheyrir tilteknum hlut, eins og í {\tt fruit.length()}.
Munurinn er auðvitað sá að fallakalli fylgir viðfangalisti, jafnvel þó hann sé tómur.

\index{yfirlýsing}
\index{setning!yfirlýsing}
\index{tilvísun}
\index{stöðurit}
\index{staða}

Niðurstaðan af þessum gildisveitingum sést í eftirfarandi stöðuriti:

\vspace{0.1in}
\centerline{\epsfig{figure=point.eps}}
\vspace{0.1in}

Að venju birtist nafn breytunnar {\tt blank} utan kassans en gildi hennar innan hans.
Í þessu tilviki er gildið samsettur hlutur með tveimur tilvikabreytum.

\section{Aðgangur að tilvikabreytum}
\index{struct!tilvikabreytur}

Þú getur lesið gildi tilvikabreytu með því að nota sömu málskipan og við notuðum til að gefa henni gildi:

\begin{verbatim}
    int x = blank.x;
\end{verbatim}
%
Segðin {\tt blank.x} merkri ``farðu í hlutinn með nafninu {\tt blank} og náðu í gildið á {\tt x}.''
Í þessu tilviki gefum við staðværri breytu með nafninu {\tt x} það gildi.
Taktu eftir því að þá er enginn ``árekstur'' á milli staðværu breytunnar {\tt x} og tilvikabreytunnar {\tt x}.
Tilgangur punktatáknunar er einmitt sá að gefa til kynna hvaða breytu þú ert að vísa í án þess að einhver margræðni sé til staðar.

Hægt er að nota punktatáknun sem hluta af hvaða C++ segð sem er, þannig að eftirfarandi er t.d. löglegt:

\begin{verbatim}
  cout << blank.x << ", " << blank.y << endl;
  double distance = blank.x * blank.x + blank.y * blank.y;
\end{verbatim}
%
Fyrri línar skrifar út {\tt 3, 4} og seinni línan reiknar út gildið 25.

\section{Aðgerðir á strúktúrum}
\index{struct!aðgerðir}

Flestum af þeim aðgerðum sem við höfum notað á önnur tög, eins og stærðfræðivirkjarnir (e. mathematical operators) ( {\tt +}, {\tt \%}, o.s.frv.)
og samanburðarvirkjarnir (e. comparison operators) ({\tt ==}, {\tt >}, o.s.frv.) er ekki hægt að beita á strúktúra.
Reyndar er hægt að breyta merkingu þessara virkja fyrir ný tög en við munum ekki fjalla um það í þessari bók.

Gildisveitingarvirkjanum (e. assignment operator) er aftur á móti hægt að beita á strúktúra.
Hægt er að nota hann á tvo vegu: til að upphafsstilla tilvikabreytu strúktúrs eða til að afrita gildi tilvikabreytu úr einum strúktúr í annan.
Upphafsstilling lítur svona út:

\begin{verbatim}
  Point blank = { 3.0, 4.0 };
\end{verbatim}
%
Tilvikabreytur breytunnar {\tt blank} fá hér gildin úr slaufusviganum, í þeirri röð sem þau eru sett fram.
Þannig að hér fær {\tt blank.x} fyrsta gildið (3.0) og {\tt blank.y} annað gildið (4.0). 

Því miður er eingöngu hægt að nota þessa málskipan í upphafsstillingu en ekki í gildisveitingarsetningu.
Eftirfarandi er því ekki löglegt:

\begin{verbatim}
  Point blank;
  blank = { 3.0, 4.0 };       // WRONG !!
\end{verbatim}
%
Það er eðlilegt að velta því fyrir sér hver ástæðan er fyrir því að jafn eðlileg setning sé óleyfileg.
Ég er ekki alveg viss en vandamálið gæti verið það að þýðandinn veit ekki hvert tagið á hægri hliðinni er.
Ef þú bætir við tagmótun (e. typecast) þá er allt í fína:

\begin{verbatim}
  Point blank;
  blank = (Point){ 3.0, 4.0 };
\end{verbatim}
%

Það er jafnframt leyfilegt að gefa einum stŕúktúr gildi annars strúkturs. Dæmi: 

\begin{verbatim}
  Point p1 = { 3.0, 4.0 };
  Point p2 = p1;
  cout << p2.x << ", " <<  p2.y << endl;
\end{verbatim}
%
Úttakið úr þessu forriti er {\tt 3, 4}.

\section{Strúktúrar sem viðföng}
\index{viðfang}
\index{struct!viðfang}

Þú getur haft strúktúr sem lepp í falli, t.d. :

\begin{verbatim}
void printPoint (Point p) {
  cout << "(" << p.x << ", " << p.y << ")" << endl;
}
\end{verbatim}
%
{\tt printPoint} tekur punkt sem viðfang og skrifar gildi hans út á staðlaðan hátt.
Ef þú kallar á fallið með {\tt printPoint (blank)} þá skrifast út {\tt (3, 4)}.

Tökum annað dæmi.  Við getum endurskrifað {\tt distance} fallið úr kafla~\ref{distance} þannig að það taki tvo punkta sem viðföng í stað fjögurrra kommutalna:

\begin{verbatim}
double distance (Point p1, Point p2) {
  double dx = p2.x - p1.x;
  double dy = p2.y - p1.y;
  return sqrt (dx*dx + dy*dy);
}
\end{verbatim}

\section{Kallað með gildi}
\index{stikun færibreytna}
\index{kall!með gildi}

Það er mikilvægt að gera sér grein fyrir því að þegar strúktúr er sendur sem viðfang í fall þá er viðfangið (e. argument/actual parameter) og leppurinn (e. formal parameter) ekki sama breytan.
Um er að ræða tvær breytur (önnur í þeim sem kallar (e. caller) og hin í þeim sem kallað er á (e. callee)) sem hafa sama gildið, a.m.k. í upphafi.
Þegar við t.d. köllum á {\tt printPoint} þá lítur stöðuritið svona út: 

\vspace{0.1in}
\centerline{\epsfig{figure=point2.eps}}
\vspace{0.1in}
%
Ef {\tt printPoint} breytir annarri (eða báðum) tilvikabreytum {\tt p} þá mun það ekki hafa nein áhrif á {\tt blank} (auðvitað er engin ástæða fyrir {\tt printPoint} að breyta leppnum sínum).

Þessi tegund af {\bf stikun færibreytna} (e. parameter passing) er kölluð ``kall með gildi'' (e. ``pass by value'')
vegna þess að gildi (e. value) strúktúrsins (eða hvaða tags sem er) er sent til fallsins.

\section{Kallað með tilvísun}
\index{stikun færibreytna}
\index{kall!með tilvísun}
\index{tilvísun}

Önnur aðferð við stikun færibreytna í C++ er ``kall með tilvísun'' (e. ``pass by reference'').
Þessi aðferð gerir þér kleift að senda strúktúr í fall og breyta gildum hans!

Þú gætir t.d. speglað punkti um 45-gráðu línuna með því að skipta gildum hnitanna tveggja.
Augljósasta leiðin (en ekki sú rétta) er að útfæra {\tt reflect} fallið á þennan hátt:

\begin{verbatim}
void reflect (Point p)      // WRONG !!
{
  double temp = p.x;
  p.x = p.y;
  p.y = temp;
}
\end{verbatim}
%
Þetta virkar ekki vegna þess að það að gera breytingar á leppnum í {\tt reflect} hefur engin áhrif á þann sem kallaði.

Í staðinn verðum við að tilgreina að við ætlum að senda viðfangið með tilvísun (e. by reference).
Það gerum við með því að bæta tákninu {\tt \&} við í skilgreiningu á leppunum: 

\begin{verbatim}
void reflect (Point& p)
{
  double temp = p.x;
  p.x = p.y;
  p.y = temp;
}
\end{verbatim}
%
Núna getum við kallað á fallið á hefðbundin hátt:

\begin{verbatim}
  printPoint (blank);
  reflect (blank);
  printPoint (blank);
\end{verbatim}
%
Úttak forritsins er eins og við gerum ráð fyrir: 

\begin{verbatim}
(3, 4)
(4, 3)
\end{verbatim}
%
Svona myndi síðan stöðurit líta út fyrir þetta forrit:

\vspace{0.1in}
\centerline{\epsfig{figure=point3.eps}}
\vspace{0.1in}
%
Leppurinn {\tt p} er tilvísun í strúktúr með nafnið {\tt blank}.
Hefðbundin táknun fyrir tilvísun er punktur með ör sem bendir á það sem tilvísunin vísar á.

Það mikilvæga sem hægt er að lesa úr þessu stöðuriti er að allar breytingar sem 
{\tt reflect} gerir á {\tt p} munu einnig hafa áhrif á {\tt blank}.

Það að stika strúktúr með tilvísun (e. by reference) er sveigjanlegra heldur en stika hann með gildi (e. by value)
vegna þess að sá sem kallað er á getur breytt strúktúrnum.
Það er jafnframt hraðvirkara vegna þess að kerfið þarf ekki að afrita heilan strúktúr.
Á hinn bóginn má segja að það sé ekki eins öruggt vegna þess að það er erfiðara að gera sér grein fyrir hvaða breytingar eru gerðar hvar.
Samt sem áður eru strúktúrar yfirleitt stikaðir með tilvísun í C++ forritum og ég mun fylgja þeirri venju í þessari bók.

\section{Rectangles}
\index{Rectangle}
\index{struct!Rectangle}

Now let's say that we want to create a structure to represent
a rectangle.  The question is, what information do I have to
provide in order to specify a rectangle?  To keep things simple
let's assume that the rectangle will be oriented vertically or
horizontally, never at an angle.

There are a few possibilities: I could specify the center of
the rectangle (two coordinates) and its size (width and height),
or I could specify one of the corners and the size, or I
could specify two opposing corners.

The most common choice in existing programs is to specify the
upper left corner of the rectangle and the size.  To do that
in C++, we will define a structure that contains a {\tt Point}
and two doubles.

\begin{verbatim}
struct Rectangle {
  Point corner;
  double width, height;
};  
\end{verbatim}
%
Notice that one structure can contain another.  In fact, this
sort of thing is quite common.  Of course, this means that in
order to create a {\tt Rectangle}, we have to create a {\tt Point}
first:

\begin{verbatim}
  Point corner = { 0.0, 0.0 };
  Rectangle box = { corner, 100.0, 200.0 };
\end{verbatim}
%
This code creates a new {\tt Rectangle} structure and initializes the
instance variables.  The figure shows the effect of this assignment.

\vspace{0.1in}
\centerline{\epsfig{figure=rectangle.eps}}
\vspace{0.1in}
%
We can access the {\tt width} and {\tt height} in the usual way:

\begin{verbatim}
  box.width += 50.0;
  cout << box.height << endl;
\end{verbatim}
%
In order to access the instance variables of {\tt corner}, we can use a
temporary variable:

\begin{verbatim}
  Point temp = box.corner;
  double x = temp.x;
\end{verbatim}
%
Alternatively, we can compose the two statements:

\index{composition}

\begin{verbatim}
  double x = box.corner.x;
\end{verbatim}
%
It makes the most sense to read this statement from right to
left: ``Extract {\tt x} from the {\tt corner} of the {\tt box},
and assign it to the local variable {\tt x}.''

While we are on the subject of composition, I should point
out that you can, in fact, create the {\tt Point} and the
{\tt Rectangle} at the same time:

\begin{verbatim}
  Rectangle box = { { 0.0, 0.0 }, 100.0, 200.0 };
\end{verbatim}
%
The innermost squiggly braces are the coordinates of the
corner point; together they make up the first of the three
values that go into the new {\tt Rectangle}.  This statement
is an example of {\bf nested structure}.

\index{nested structure}


\section{Structures as return types}
\index{struct!as return type}
\index{return}
\index{statement!return}

You can write functions that return structures.  For example,
{\tt findCenter} takes a {\tt Rectangle} as an argument and
returns a {\tt Point} that contains the coordinates of the
center of the {\tt Rectangle}:

\begin{verbatim}
Point findCenter (Rectangle& box)
{
  double x = box.corner.x + box.width/2;
  double y = box.corner.y + box.height/2;
  Point result = {x, y};
  return result;
}
\end{verbatim}
%
To call this function, we have to pass a box as an argument
(notice that it is being passed by reference), and assign the
return value to a {\tt Point} variable:

\begin{verbatim}
  Rectangle box = { {0.0, 0.0}, 100, 200 };
  Point center = findCenter (box);
  printPoint (center);
\end{verbatim}
%
The output of this program is {\tt (50, 100)}.

\section {Passing other types by reference}
\index{parameter passing}
\index{call by reference}
\index{reference}

It's not just structures that can be passed by reference.
All the other types we've seen can, too.  For example, to swap
two integers, we could write something like:

\begin{verbatim}
void swap (int& x, int& y)
{
  int temp = x;
  x = y;
  y = temp;
}
\end{verbatim}
%
We would call this function in the usual way:

\begin{verbatim}
  int i = 7;
  int j = 9;
  swap (i, j);
  cout << i << j << endl;
\end{verbatim}
%
The output of this program is {\tt 97}.  Draw a stack
diagram for this program to convince yourself this is true.
If the parameters {\tt x} and {\tt y} were declared as
regular parameters (without the {\tt \&}s), {\tt swap} would
not work.  It would modify {\tt x} and {\tt y} and have no
effect on {\tt i} and {\tt j}.

When people start passing things like integers by reference,
they often try to use an expression
as a reference argument.  For example:

\begin{verbatim}
  int i = 7;
  int j = 9;
  swap (i, j+1);         // WRONG!!
\end{verbatim}
%
This is not legal because the expression {\tt j+1} is not
a variable---it does not occupy a location that the reference
can refer to.  It is a little tricky to figure out exactly
what kinds of expressions can be passed by reference.  For now
a good rule of thumb is that reference arguments have to be
variables.

\section{Getting user input}
\label{input}
\index{input!keyboard}

The programs we have written so far are pretty predictable;
they do the same thing every time they run.  Most of the time,
though, we want programs that take input from the user and
respond accordingly.

There are many ways to get input, including keyboard
input, mouse movements and button clicks, as well as more exotic
mechanisms like voice control and retinal scanning.  In this
text we will consider only keyboard input.

\index{stream}
\index{cin}
\index{cout}

In the header file {\tt iostream},
C++ defines an object named {\tt cin} that handles input in
much the same way that {\tt cout} handles output.  To get an
integer value from the user:

\begin{verbatim}
  int x;
  cin >> x;
\end{verbatim}
%
The {\tt >>} operator causes the program to stop executing and
wait for the user to type something.  If the user types a valid
integer, the program converts it into an integer value and
stores it in {\tt x}.

\index{operator!{\tt >>}}

If the user types something other than an integer,
C++ doesn't report an error, or anything sensible like that.
Instead, it puts some meaningless value in {\tt x} and continues.

Fortunately, there is a way to check and see if an input
statement succeeds.  We can invoke the {\tt good} function on
{\tt cin} to check what is called the {\bf stream state}.
{\tt good} returns a {\tt bool}: if true, then the last input
statement succeeded.  If not, we know that some previous operation
failed, and also that the next operation will fail.

Thus, getting input from the user might look like this:

\begin{verbatim}
#include <iostream>

using namespace std;

int main ()
{
  int x;

  // prompt the user for input
  cout << "Enter an integer: ";

  // get input
  cin >> x;

  // check and see if the input statement succeeded
  if (cin.good() == false) {
    cout << "That was not an integer." << endl;
    return -1;
  }

  // print the value we got from the user
  cout << x << endl;
  return 0;
}
\end{verbatim}
%
{\tt cin} can also be used to input a {\tt string}:

\begin{verbatim}
  string name;

  cout << "What is your name? ";
  cin >> name;
  cout << name << endl;
\end{verbatim}
%
Unfortunately, this statement only takes the first word of
input, and leaves the rest for the next input statement.
So, if you run this program and type your full name, it
will only output your first name.

Because of these problems (inability to handle errors and
funny behavior), I avoid using the {\tt >>} operator altogether,
unless I am reading data from a source that is known to be
error-free.

Instead, I use a function in the header {\tt string} called {\tt getline}.

\begin{verbatim}
  string name;

  cout << "What is your name? ";
  getline (cin, name);
  cout << name << endl;
\end{verbatim}
%
The first argument to {\tt getline} is {\tt cin}, which is
where the input is coming from.  The second argument is the
name of the {\tt string} where you want the result to be
stored.

{\tt getline} reads the entire line until the user hits
Return or Enter.  This is useful for inputting strings that
contain spaces.

In fact, {\tt getline} is generally useful for getting input
of any kind.  For example, if you wanted the user to type an
integer, you could input a string and then check to see if
it is a valid integer.  If so, you can convert it to an integer
value.  If not, you can print an error message and ask the user
to try again.

To convert a string to an integer you can use the {\tt atoi}
function defined in the header file {\tt cstdlib}.  We will
get to that in Section~\ref{parsing}.

\section{Glossary}

\begin{description}

\item[structure:]  A collection of data grouped together and
treated as a single object.

\item[instance variable:]  One of the named pieces of data that make up
a structure.

\item[reference:]  A value that indicates or refers to a variable
or structure.  In a state diagram, a reference appears as an arrow.

\item[pass by value:]  A method of parameter-passing in which the
value provided as an argument is copied into the corresponding
parameter, but the parameter and the argument occupy distinct
locations.

\item[pass by reference:]  A method of parameter-passing in which
the parameter is a reference to the argument variable.  Changes
to the parameter also affect the argument variable.

\index{structure}
\index{instance variable}
\index{reference}
\index{pass by value}
\index{pass by reference}

\end{description}

