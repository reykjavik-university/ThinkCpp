% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

% This is an Icelandic translation/adaptation by Hrafn Loftsson of the orginal book by Allen B. Downey.

%\chapter{Objects of Vectors}
\chapter{Hlutir með vektorum}

%\section{Enumerated types}
\section{Upptalningartög}
\index{tag!upptalning}
\index{upptalningartag}
\index{vörpun}

Í kaflanum hér á undan ræddi ég um vörpun á milli raunverulegra gilda, eins og gilda eða lita tiltekinna spila, 
og innri framsetningar, eins og heiltalna og strengja.
Þó svo að við höfum annars vegar búið til vörpun á milli gilda og heiltalna og hins vegar á milli lita og heiltalna
þá benti ég á að vörpunin sjálf kemur ekki beint fram í forritskóðanum.

Reyndar vill svo til að C++ hefur eiginleika sem kallast {\bf upptalningartag} (e. enumerated type)
sem gerir kleift (1) að gera vörpun sem hluta af forritskóða og (2) að skilgreina mengi af gildum sem vörpunin samanstendur af.
Hér er t.d. skilgreiningin á upptalningartagi fyrir {\tt Suit} og {\tt Rank}:

\begin{verbatim}
enum Suit { CLUBS, DIAMONDS, HEARTS, SPADES };

enum Rank { ACE=1, TWO, THREE, FOUR, FIVE, SIX, SEVEN, EIGHT, NINE,
TEN, JACK, QUEEN, KING };
\end{verbatim}
%
Sjálfgefin vörpun er sú að fyrsta gildið í upptalningartagi varpast í heiltöluna 0, annað gildið í 1, o.s.frv.
Í {\tt Suit} taginu stendur því gildið {\tt CLUBS} fyrir heiltöluna 0, {\tt DIAMONDS} fyrir 1, o.s.frv.

Skilgreiningin á {\tt Rank} yfirskrifar sjálfgefnu vörpunina og tilgreinir að {\tt ACE} standi fyrir heiltöluna 1.
Þar með varpast {\tt TWO} í 2,  {\tt THREE} í 3, o.s.frv.

Um leið og við höfum skilgreint þessi tög getum við notað þau hvar sem er.
Meðlimabreytunum {\tt rank} og {\tt suit} getur t.d. verið lýst yfir með tögunum {\tt Rank} og {\tt Suit}:

\begin{verbatim}
struct Card
{
  Rank rank;
  Suit suit;

  Card (Suit s, Rank r);
};
\end{verbatim}
%
Taktu eftir að tag leppanna í smiðnum hefur líka breyst.
Til að ``smíða'' card hlut getum við þá notað gildi úr upptalningartögunum sem viðföng:

\begin{verbatim}
  Card card (DIAMONDS, JACK);
\end{verbatim}
%
Það er hefð fyrir því að gildi úr upptalningartögum séu nöfn með stórum stöfum.
Þessi yfirlýsing á card hlut er miklu læsilegri en sú sem við notuðum áður með heiltölum:

\begin{verbatim}
  Card card (1, 11);
\end{verbatim}
%
Við getum notað gildi upptalningartaga sem vísi inn í vektora vegna þess að við vitum 
að þessi gildi standa fyrir heiltölur.
Af þessum sökum mun gamla {\tt print} fallið okkar virka á nokkurra breytinga.
Við þurfum hins vegar að gera breytingar á {\tt buildDeck} fallinu:

\begin{verbatim}
  int index = 0;
  for (Suit suit = CLUBS; suit <= SPADES; suit = Suit(suit+1)) {
    for (Rank rank = ACE; rank <= KING; rank = Rank(rank+1)) {
      deck[index].suit = suit;
      deck[index].rank = rank;
      index++;
    }
  }
\end{verbatim}
%
Með því að nota upptalningartögin er kóðinn læsilegri en það er ein flækja.
Strangt til tekið getum við ekki beitt útreikningum á upptalningartög þannig að {\tt suit++} er ekki löglegt.
Hins vegar breytir C++ upptalningargildinu suit í segðinni {\tt suit+1} í heiltölu.
Þar með getum við tekið niðurstöðuna og notað tagmótun (e. typecast) til að ``kasta'' gildinu til baka í upptalningartag: 

\begin{verbatim}
  suit = Suit(suit+1);
  rank = Rank(rank+1);
\end{verbatim}
%
Það er reyndar til betri leið til að gera þetta með því að yfirskrifa {\tt ++} virkjann fyrir
upptalningartögin en við fjöllum ekki um það í þessari bók. 

\section{{\tt switch} setning}
\index{switch setning}
\index{setning!switch}

Það er erfitt að ræða upptalningartög án þess að nefna {\tt switch} setningar því oft haldast þær í hendur.
{\tt switch} setning er önnur leið til að setja fram keðjur af if-skilyrðissetningum og oft reyndar bæði læsilegri og skilvirkari. 
Hún lítur svona út:

\begin{verbatim}
  switch (symbol) {
  case '+':
    perform_addition ();
    break;
  case '*':
    perform_multiplication ();
    break;
  default:
    cout << "I only know how to perform addition and multiplication" << endl;
    break;
  }
\end{verbatim}
%
Þessi {\tt switch} setning er jafngild eftirfarandi keðju af if-setningum:

\begin{verbatim}
  if (symbol == '+') {
    perform_addition ();
  } else if (symbol == '*') {
    perform_multiplication ();
  } else {
    cout << "I only know how to perform addition and multiplication" << endl;
  }
\end{verbatim}
%
{\tt break} setningarnar eru nauðsynlegar í sérhverri ``grein'' í 
{\tt switch} setningu vegna þess að án {\tt break} setningar þá ``fellur'' keyrsluflæðið í næsta tilvik (e. case).
Án {\tt break} setninga myndi táknið {\tt +} verða þess valdandi að forritið myndi framkvæma
samlagningu (e. addition), síðan margföldun (e. multiplication) og að lokum prenta út villuskilaboðin.
Af og til er þessi eiginleiki reyndar gagnlegur en í flestum tilvikum koma upp villur í keyrslu þegar 
{\tt break} setningar gleymast.

\index{break setning}
\index{setning!break}

{\tt switch} setningar virka fyrir heiltölur, stafi og upptalningatög.
Til að breyta {\tt Suit} í samsvarandi streng þá getum við t.d. gert eftirfarandi: 

\begin{verbatim}
  switch (suit) {
  case CLUBS:     return "Clubs";
  case DIAMONDS:  return "Diamonds";
  case HEARTS:    return "Hearts";
  case SPADES:    return "Spades";
  default:        return "Not a valid suit";
  }
\end{verbatim}
%
Í þessu dæmi þurfum við ekki á {\tt break} setningu að halda vegna þess að 
{\tt return} setningar valda því að keyrsluflæðið fer til baka til þess sem kallaði í stað þess
að ``falla'' í næsta tilvik. 

\index{default}

Almennt séð er góður forritunarstíll að hafa sjálfgefið ({\tt default}) tilvik í sérhverri     
{\tt switch} setningu til að meðhöndla villur eða óvænt gildi. 

\section{Stokkar}
\label{deck}
\index{stokkur}
\index{vektor!af spilum}

Í köflunum hér á undan unnum við með vektor af hlutum 
en ég nefndi það líka að það væri hægt að búa til hluti 
sem innihalda vektor sem meðlimabreytu.
Í þessum kafla ætla ég að búa til nýjan hlut, {\tt Deck},
sem inniheldur vektor af {\tt Card}.

\index{meðlimabreyta}
\index{breyta!meðlimur}

Strúktúrskilgreiningin lítur svona út:

\begin{verbatim}
struct Deck {
  vector<Card> cards;

  Deck (int n);
};

Deck::Deck (int size)
{
  vector<Card> temp (size);
  cards = temp;
}
\end{verbatim}
%
Nafnið á meðlimabreytunni er {\tt cards} sem hjálpar okkur að gera
greinarmun á {\tt Deck} (stokknum) sjálfum og vektor af {\tt Card} sem stokkurinn inniheldur.


\index{smiður}

Sem stendur er aðeins um einn smið að ræða.
Sá nýtir sér staðværa breytu með nafninu {\tt temp} sem er upphafsstillt
með því að vekja upp smiðinn í {\tt vector} klasanum (stærðin, size, er send sem viðfang).
Síðan afritar smiðurinn {\tt temp} yfir í meðlimabreytuna {\tt cards}.

Nú getum við þá búið til stokk af spilum á eftirfarandi hátt: 

\begin{verbatim}
  Deck deck (52);
\end{verbatim}
%
Stöðurit fyrir {\tt Deck} hlut lítur svona út:

\index{stöðurit}
\index{smiður}

\vspace {0.1in}
\centerline{\epsfig{figure=deckobject.eps}}
\vspace {0.1in}

Hluturinn með nafnið {\tt deck} á sér eina meðlimabreytu með nafnið {\tt cards}
sem er vektor af {\tt Card} hlutum.
Til að nálgast spil í stokknum þurfum við að setja saman málskipanina fyrir að nálgast meðlimabreytu
og málskipanina fyrir að velja stak úr vektor.
Segðin {\tt deck.cards[i]} er t.d. i-ta spilið í stokknum og
{\tt deck.cards[i].suit} er litur þess.

Eftirfarandi lykkja

\begin{verbatim}
  for (int i = 0; i<52; i++) {
    deck.cards[i].print();
  }
\end{verbatim}
%
sýnir hvernig er hægt að ferðast um í stokknum og prenta út sérhvert spil.

\section {Annar smiður}
\index{smiður}

Það getur verið gagnlegt að upphafsstilla spilin í {\tt Deck} hlutnum.
Við gætum notað fallið {\tt buildDeck} úr fyrri kafla (með smávægilegum breytingum) 
en það er líklega eðlilegra að skrifa annan smið í {\tt Deck}.

\index{lykkja!hreiðruð}

\begin{verbatim}
Deck::Deck ()
{
  vector<Card> temp (52);
  cards = temp;

  int i = 0;
  for (Suit suit = CLUBS; suit <= SPADES; suit = Suit(suit+1)) {
    for (Rank rank = ACE; rank <= KING; rank = Rank(rank+1)) {
      cards[i].suit = suit;
      cards[i].rank = rank;
      i++;
    }
  }
}
\end{verbatim}
%
Taktu eftir því hversu líkt þetta fall er {\tt buildDeck} -- við þurftum aðeins að breyta málskipaninni til að gera þetta að smið.
Nú getum við búið til hefðbundinn 52-spila stokk með einfaldri yfirlýsingu: {\tt Deck deck;}

\section {Meðlimaföll í {\tt Deck}}
\index{meðlimaföll}
%\index{function!member}

Nú þegar við höfum sérstakan {\tt Deck} hlut þá er eðlilegt að gera öll föll, sem hafa með stokk að gera, að
meðlimaföllum í {\tt Deck}.
Einn augljós kandídat er fallið {\tt printDeck} (kafli~\ref{printdeck}).
Svona lítur það út eftir að því hefur verið breytt í meðlimafall í {\tt Deck}:

\index{printDeck}

\begin{verbatim}
void Deck::print () const {
  for (int i = 0; i < cards.length(); i++) {
    cards[i].print ();
  }
}
\end{verbatim}
%
Að venju getum við vísað í meðlimabreytu núverandi hlutar (t.d. {\tt cards}) án þess að nota punktatáknun (e. dot notation).

Það er hins vegar ekki augljóst fyrir sum önnur föll hvort þau ættu að vera
meðlimaföll í {\tt Card}, í {\tt Deck} eða föll sem standa eitt og sér (e. nonmember function)
og taka {\tt Card} og {\tt Deck} hluti sem viðföng.
Útgáfan af {\tt find} úr fyrri kafla tekur t.d. {\tt Card} og {\tt Deck} hluti sem viðföng
en við gætum gert fallið að meðlimafalli annars hvors hlutarins. 
Til að æfa þig skaltu núna endurskrifa {\tt find} sem meðlimafall í {\tt Deck} sem tekur
{\tt Card} hlut sem viðfang. 

Það að skrifa {\tt find} sem meðlimafall í {\tt Card} er aftur á móti dálítið snúið.
Hér er mín útgáfa: 

\begin{verbatim}
int Card::find (const Deck& deck) const {
  for (int i = 0; i < deck.cards.length(); i++) {
    if (equals (deck.cards[i], *this)) return i;
  }
  return -1;
}
\end{verbatim}
%
Fyrsta ``vandamálið'' er að við verðum að nota lykilorðið {\tt this}
til að vísa í það spil sem fallið er vakið upp með.

\index{strúktúrskilgreining}

Annað vandamálið er það að C++ gerir ekki auðvelt að skrifa strúktúrskilgreiningar
sem vísa hvor á aðra.
Vandamálið er að þegar þýðandinn les fyrri skilgreininguna þá hefur það ekki séð þá seinni.

Ein lausn er að lýsa {\tt Deck} yfir (e. declare) á undan {\tt Card} og síðan skilgreina (e. define) {\tt Deck} eftir það:

\begin{verbatim}
// declare that Deck is a structure, without defining it
struct Deck;

// that way we can refer to it in the definition of Card
struct Card
{
  int suit, rank;

  Card ();
  Card (int s, int r);

  void print () const;
  bool isGreater (const Card& c2) const;
  int find (const Deck& deck) const;
};

// and then later we provide the definition of Deck
struct Deck {
  vector<Card> cards;

  Deck ();
  Deck (int n);
  void print () const;
  int find (const Card& card) const;
};
\end{verbatim}


\section{Shuffling}
\label{shuffle}
\index{shuffling}

For most card games you need to be able to shuffle the deck;
that is, put the cards in a random order.  In Section~\ref{random}
we saw how to generate random numbers, but it is not obvious how
to use them to shuffle a deck.

One possibility is to model the way humans shuffle, which is usually
by dividing the deck in two and then reassembling the deck by choosing
alternately from each deck.  Since humans usually don't shuffle
perfectly, after about 7 iterations the order of the deck is pretty
well randomized.  But a computer program would have the annoying
property of doing a perfect shuffle every time, which is not really
very random.  In fact, after 8 perfect shuffles, you would find the
deck back in the same order you started in.  For a discussion of that
claim, see {\tt http://www.wiskit.com/marilyn/craig.html} or do a web
search with the keywords ``perfect shuffle.''

A better shuffling algorithm is to traverse the deck one card at a
time, and at each iteration choose two cards and swap them.

\index{pseudocode}

Here is an outline of how this algorithm works.  To sketch the
program, I am using a combination of C++ statements and English
words that is sometimes called {\bf pseudocode}:

\begin{verbatim}
  for (int i=0; i<cards.length(); i++) {
    // choose a random number between i and cards.length()
    // swap the ith card and the randomly-chosen card
  }
\end{verbatim}
%
The nice thing about using pseudocode is that it often makes it
clear what functions you are going to need.  In this case, we
need something like {\tt randomInt}, which chooses a random
integer between the parameters {\tt low} and {\tt high},
and {\tt swapCards} which takes two indices and switches the
cards at the indicated positions.

\index{random number}

You can probably figure out how to write {\tt randomInt}
by looking at Section~\ref{random}, although you will have to
be careful about possibly generating indices that are out of range.

\index{swapCards}
\index{reference}

You can also figure out {\tt swapCards} yourself.
I will leave the remaining implementation of these functions
as an exercise to the reader.

\section{Sorting}
\label{sorting}
\index{sorting}

Now that we have messed up the deck, we need a way to put it
back in order.  Ironically, there is an algorithm for
sorting that is very similar to the algorithm for shuffling.

Again, we are going to traverse the deck and at each location
choose another card and swap.  The only difference is that
this time instead of choosing the other card at random, we
are going to find the lowest card remaining in the deck.

By ``remaining in the deck,'' I mean cards that are at or
to the right of the index {\tt i}.

\begin{verbatim}
  for (int i=0; i<cards.length(); i++) {
    // find the lowest card at or to the right of i
    // swap the ith card and the lowest card
  }
\end{verbatim}
%
Again, the pseudocode helps with the design of the {\bf helper
functions}.  In this case we can use {\tt swapCards} again,
so we only need one new one, called {\tt findLowestCard},
that takes a vector of cards and an index where it should
start looking.

This process, using pseudocode to figure out what helper
functions are needed, is sometimes called {\bf top-down
design}, in contrast to the bottom-up design I discussed
in Section~\ref{counting}.

\index{top-down design}
\index{program development!top-down}
\index{bottom-up design}
\index{program development!bottom-up}
\index{helper function}
\index{function!helper}

Once again, I am going to leave the implementation up to
the reader.

\section {Subdecks}
\index{subdeck}

How should we represent a hand or some other subset of a full deck?
One easy choice is to make a {\tt Deck} object that
has fewer than 52 cards.

We might want a function, {\tt subdeck}, that takes a vector of cards
and a range of indices, and that returns a new vector of cards that
contains the specified subset of the deck:

\begin{verbatim}
Deck Deck::subdeck (int low, int high) const {
  Deck sub (high-low+1);
	
  for (int i = 0; i<sub.cards.length(); i++) {
    sub.cards[i] = cards[low+i];
  }
  return sub;
}
\end{verbatim}
%
To create the local variable named {\tt subdeck} we are using
the {\tt Deck} constructor that takes the size of the deck
as an argument and that does not initialize the cards.  The
cards get initialized when they are copied from the original
deck.

The length of the subdeck is {\tt high-low+1} because both the low
card and high card are included.  This sort of computation can be
confusing, and lead to ``off-by-one'' errors.  Drawing a picture is
usually the best way to avoid them.

\index{constructor}
\index{overloading}

As an exercise, write a version of {\tt findBisect} that takes a
subdeck as an argument, rather than a deck and an index range.  Which
version is more error-prone?  Which version do you think is more
efficient?

\section{Shuffling and dealing}
\index{shuffling}
\index{dealing}

In Section~\ref{shuffle} I wrote pseudocode for a shuffling algorithm.
Assuming that we have a function called {\tt shuffleDeck} that takes
a deck as an argument and shuffles it, we can create and shuffle
a deck:

\begin{verbatim}
  Deck deck;               // create a standard 52-card deck
  deck.shuffle ();         // shuffle it
\end{verbatim}
%
Then, to deal out several hands, we can use {\tt subdeck}:

\begin{verbatim}
  Deck hand1 = deck.subdeck (0, 4);
  Deck hand2 = deck.subdeck (5, 9);
  Deck pack = deck.subdeck (10, 51);
\end{verbatim}
%
This code puts the first 5 cards in one hand, the next 5 cards
in the other, and the rest into the pack.

When you thought about dealing, did you think we should give out one
card at a time to each player in the round-robin style that is common
in real card games?  I thought about it, but then realized that it is
unnecessary for a computer program.  The round-robin convention is
intended to mitigate imperfect shuffling and make it more difficult
for the dealer to cheat.  Neither of these is an issue for a computer.

This example is a useful reminder of one of the dangers of engineering
metaphors: sometimes we impose restrictions on computers that are
unnecessary, or expect capabilities that are lacking, because we
unthinkingly extend a metaphor past its breaking point.  Beware of
misleading analogies.


\section {Mergesort}
\index{efficiency}
\index{sorting}
\index{mergesort}

In Section~\ref{sorting}, we saw a simple sorting algorithm that turns
out not to be very efficient.  In order to sort $n$ items, it has to
traverse the vector $n$ times, and each traversal takes an amount of
time that is proportional to $n$.  The total time, therefore, is
proportional to $n^2$.

In this section I will sketch a more efficient algorithm called {\bf
mergesort}.  To sort $n$ items, mergesort takes time proportional to
$n \log n$.  That may not seem impressive, but as $n$ gets big, the
difference between $n^2$ and $n \log n$ can be enormous.  Try out a
few values of $n$ and see.

The basic idea behind mergesort is this: if you have two subdecks,
each of which has been sorted, it is easy (and fast) to merge them
into a single, sorted deck.  Try this out with a deck of cards:

\begin{enumerate}

\item Form two subdecks with about 10 cards each and sort
them so that when they are face up the lowest cards are on
top.  Place both decks face up in front of you.

\item Compare the top card from each deck and choose the
lower one.  Flip it over and add it to the merged deck.

\item Repeat step two until one of the decks is empty.
Then take the remaining cards and add them to the merged
deck.

\end{enumerate}

The result should be a single sorted deck.  Here's what this
looks like in pseudocode:

\begin{verbatim}
  Deck merge (const Deck& d1, const Deck& d2) {
    // create a new deck big enough for all the cards
    Deck result (d1.cards.length() + d2.cards.length());

    // use the index i to keep track of where we are in
    // the first deck, and the index j for the second deck
    int i = 0;
    int j = 0;
		
    // the index k traverses the result deck
    for (int k = 0; k<result.cards.length(); k++) {
			
      // if d1 is empty, d2 wins; if d2 is empty, d1 wins;
      // otherwise, compare the two cards
			
      // add the winner to the new deck
    }
    return result;
  }
\end{verbatim}
%
I chose to make {\tt merge} a nonmember function because
the two arguments are symmetric.

The best way to test {\tt merge} is to build and shuffle a deck,
use subdeck to form two (small) hands, and then use the sort
routine from the previous chapter to sort the two halves.  Then
you can pass the two halves to {\tt merge} to see if it works.

\index{testing}

If you can get that working, try a simple implementation of
{\tt mergeSort}:

\begin{verbatim}
Deck Deck::mergeSort () const {
  // find the midpoint of the deck
  // divide the deck into two subdecks
  // sort the subdecks using sort
  // merge the two halves and return the result
}
\end{verbatim}
%
Notice that the current object is declared {\tt const} because
{\tt mergeSort} does not modify it.  Instead, it creates and
returns a new {\tt Deck} object.

If you get that version working, the real fun begins!  The magical thing
about mergesort is that it is recursive.  At the point where you sort
the subdecks, why should you invoke the old, slow version of {\tt
sort}?  Why not invoke the spiffy new {\tt mergeSort} you are in the
process of writing?

\index{recursion}

Not only is that a good idea, it is {\em necessary} in order to
achieve the performance advantage I promised.  In order to make it
work, though, you have to add a base case so that it doesn't recurse
forever.  A simple base case is a subdeck with 0 or 1 cards.  If {\tt
mergesort} receives such a small subdeck, it can return it
unmodified, since it is already sorted.

The recursive version of {\tt mergesort} should look something
like this:

\begin{verbatim}
Deck Deck::mergeSort (Deck deck) const {
  // if the deck is 0 or 1 cards, return it

  // find the midpoint of the deck
  // divide the deck into two subdecks
  // sort the subdecks using mergesort
  // merge the two halves and return the result
}
\end{verbatim}
%
As usual, there are two ways to think about recursive programs:
you can think through the entire flow of execution, or you
can make the ``leap of faith.''  I have deliberately constructed
this example to encourage you to make the leap of faith.

\index{leap of faith}

When you were using {\tt sort} to sort the subdecks, you didn't
feel compelled to follow the flow of execution, right?  You just
assumed that the {\tt sort} function would work because you already
debugged it.  Well, all you did to make {\tt mergeSort} recursive was
replace one sort algorithm with another.  There is no reason to read
the program differently.

Well, actually you have to give some thought to getting the
base case right and making sure that you reach it eventually,
but other than that, writing the recursive version should be
no problem.  Good luck!

\section{Glossary}

\begin{description}

\item[pseudocode:]  A way of designing programs by writing
rough drafts in a combination of English and C++.

\item[helper function:]  Often a small function that does not
do anything enormously useful by itself, but which helps
another, more useful, function.

\item[bottom-up design:]  A method of program development that
uses pseudocode to sketch solutions to large problems and
design the interfaces of helper functions.

\item[mergesort:]  An algorithm for sorting a collection of
values.  Mergesort is faster than the simple algorithm in
the previous chapter, especially for large collections.

\index{pseudocode}
\index{helper function}
\index{bottom-up design}
\index{program development!bottom-up}
\index{function!helper}
\index{mergesort}


\end{description}

