% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

% This is an Icelandic translation/adaptation of the orginal book by Allen B. Downey

\chapter{Ítrun}

\section{Fjölgildisveiting}
\index{gildisveiting}
\index{setning!gildisveiting}
\index{fjölgildisveiting}

Ég hef ekki nefnt það áður að í C++ er leyfilegt að gefa breytu gildi oftar en einu sinni.
Tilgangur gildisveitingar nr. 2 er að skipta út gömlu gildi tiltekinnar breytu fyrir nýtt gildi.

\begin{verbatim}
  int fred = 5;
  cout << fred;
  fred = 7;
  cout << fred;
\end{verbatim}
%
Úttakið úr þessu forriti er {\tt 57} vegna þess að í fyrra skiptið sem við skrifum út {\tt fred}
þá er gildi breytunnar 5 en í síðari skiptið er gildið 7.

Þessi tegund af {\bf fjölgildisveitingu} (e. multiple assignment) er ástæðan fyrir því að
ég lýsti breytum sem einskonar {\em gámi} (e. container) fyrir gildi.
Þegar þú gefur breytu gildi þá breytir þú innihaldi gámsins eins og sést á eftirfarandi mynd:

\vspace{0.1in}
\centerline{\epsfig{figure=assign2.eps}}
\vspace{0.1in}

Þegar um fjölgildisveitingu er að ræða þá er sérstaklega mikilvægt að gera greinarmun á gildisveitingu og samanburði.
C++ notar {\tt =} táknið fyrir gildisveitingu en það er freistandi að túlka setningu eins og {\tt a = b} sem samanburð (jöfnuð).
Svo er hins vegar ekki!

Í fyrsta lagi þá er samanburður víxlin (e. commutative) en gildisveiting er það ekki.
Í stærðfræði ef t.d. $a = 7$ þá er $7 = a$.
En í C++ þá er setningin {\tt a = 7;} lögleg en {\tt 7 = a;} aftur á móti ekki. Af hverju ekki?

Jafnframt gildir í stærðfræði að setning um jöfnuð (e. statement of equality) er sönn án tillits til tímasetningar.
Ef $a = b$ núna, þá verður $a$ alltaf jafnt $b$.
Í C++ getur gildisveiting gert tvær breytur jafnar en þær þurfa hins vegar ekki alltaf að vera jafnar eftir það!

\begin{verbatim}
  int a = 5;
  int b = a;     // a and b are now equal
  a = 3;         // a and b are no longer equal
\end{verbatim}
%
Þriðja línan breytir gildinu á {\tt a} en breytir hins vegar ekki gildinu á {\tt b} og því eru breyturnar tvær ekki lengur jafnar.
Í mörgum forritunarmálum er annað tákn notar fyrir gildisveitingu, t.d. {\tt <-} eða {\tt :=}, til að koma í veg fyrir rugling.

Þrátt fyrir að fjölgildisveiting sé oft gagnleg þá skaltu nota hana með varúð.
Ef gildi breytna eru að stöðugt að breytast á mismunandi stöðum í forritunu þínu þá getur það orðið til þess að erfitt verði að lesa og kemba forritið.

\section{Ítrun}
\index{ítrun}

Eitt af því sem tölvur eru oft notaðar í er að sjálfvirknivæða einhæf verkefni.
Tölvur er, ólíkt fólki, góðar í því að endurtaka sama eða svipað verkefni án þess að gera villur.

Við höfum hingað til séð forrit sem beitir endurkvæmni til að framkvæma endurtekningar, t.d. {\tt nLines} og {\tt countdown}.
Þessi tegund af endurtekningum er kölluð {\bf ítrun} (e. iteration) og C++ hefur ýmsa innbyggða eiginleika sem gera okkur auðveldara að skrifa forrit sem notar ítranir.

Við ætlum nú að skoða tvo af þessum eiginleikum:
{\tt while} setningu og {\tt for} setningu.

\section{{\tt While} setning}
\index{setning!while}
\index{while setning}

Með því að nota {\tt while} setningu getum við endurskrifað {\tt countdown} fallið:

\begin{verbatim}
int countdown (int n) {
  while (n > 0) {
    cout << n << endl;
    n = n-1;
  }
  cout << "Blastoff!" << endl;
  return 0;
}
\end{verbatim}
%
Þú getur nánast lesið {\tt while} setningu eins og um væri að ræða enskan texta.
Merkingin hér er: ``While {\tt n} is greater than
zero, continue displaying the value of {\tt n} and then reducing
the value of {\tt n} by 1.  When you get to zero, output the
word `Blastoff!'''

Við getum lýst keyrsluflæðinu í {\tt while} setningu á formlegri hátt:

\begin{enumerate}

\item Gildið á skilyrðinu innan í svigunum er ákvarðað. Útkoman er annaðhvort {\tt true} eða {\tt false}.

\item Ef skilyrðið er ósatt (false), þá er hætt strax í {\tt while} setningunni og haldið áfram keyrslu í næstu setningu á eftir.

\item Ef skilyrðið er satt (true), þá er sérhver setning í blokkinni sem afmarkast af slaufusvigunum keyrð og síðan farið til baka í skref 1.

\end{enumerate}

Þessi tegund af flæði er kölluð {\bf lykkja} (e. loop) vegna þess að þriðja skrefið stekkur til baka í fyrsta skrefið.
Athugaðu að ef skilyrðið er ósatt (false) strax í upphafi þá eru setningarnar innan lykkjunnar aldrei keyrðar.
Setningarnar innan í lykkju eru kallaðar {\bf meginmál} (e. body) lykkjunnar.

\index{lykkja}
\index{lykkja!meginmál}
\index{lykkja!óendanleg}
\index{meginmál!lykkja}
\index{óendanleg lykkja}

Það er mikilvægt að meginmál lykkjunnar breyti gildi einnar eða fleiri breytna þannig að skilyrðið verði false á einhverjum tímapunkti og lykkjan hætti þá keyrslu.
Að öðrum kosti mun lykkjan halda áfram sínum ítrunum (að eilífu!) og í því tilviki er um {\bf óendanlega lykkju} (e. infinite loop) að ræða.
%An endless source of amusement for computer scientists is the observation
%that the directions on shampoo, ``Lather, rinse, repeat,'' are an infinite loop.

Í tilviki {\tt countdown} getum við sannað að lykkjan mun klárast.
Við vitum að gildið á {\tt n} minnkar um 1 í hverri {\bf ítrun} lykkjunnar þannig að {\tt n} fær gildið 0 að lokum.
Í öðrum tilfellum er kannski ekki svo auðvelt að segja til um þetta:

\begin{verbatim}
  void sequence (int n) {
    while (n != 1) {
      cout << n << endl;
      if (n%2 == 0) {           // n is even
        n = n / 2;
      } else {                  // n is odd
        n = n*3 + 1;
      }
    }
  }
\end{verbatim}
%
Skilyrði fyrir áframhaldi þessarar lykkju er {\tt n != 1} og hún heldur því áfram þangað til {\tt n} is 1 (sem gerir skilyrðin false).
Í sérhverri ítrun skrifar fallið út gildið á {\tt n} og athugar síðan hvort það er slétt tala eða oddatala.
Ef{\tt n} er slétt þá er deilt í gildið með tveimur.
Ef það er oddatala þá er gildinu skipt út fyrir $3n+1$.
Ef upphafsgildið (þ.e. gildi viðfangsins sem sent er í {\tt sequence}) á {\tt n} er t.d. 3 þá skrifast út eftirfarandi röð:
3, 10, 5, 16, 8, 4, 2, 1.

Þar sem {\tt n} hækkar stundum eða lækkar þá er ekki auðvelt að sanna að {\tt n} fái að lokum gildið 1 og þar með að lykkjan klárist að lokum.
Fyrir tiltekin gildi á {\tt n} getum við sannað að lykkjan klárist.
Ef upphafsgildið á {\tt n} er t.d. veldi af tveimur þá mun gildið á {\tt n} vera slétt tala í sérhverri ítrun lykkjunnar þangað til það verður að lokum 1.
Dæmið að ofan endar með þannig röð, þ.e. röðinni sem byrjar á 16.

Það er hins vegar athyglisvert vandamál að reyna að sanna að lykkjan hætti keyrslu fyrir {\em öll} gildi á {\tt n}.
Hingað til hefur engum tekist að sanna eða afsanna það!

\section{Töflur}
\index{tafla}
\index{lógariþmi}

Eitt af því sem hentugt er að nota lykkur í er að búa til töflugögn.
Fyrir tíma tölvunnar þurfti fólk að reikna lógariþma, sínus og cósínus, og önnur stærðfræðiföll, í höndunum.
Til að gera þetta auðveldara þá voru til bækur sem innhéldu langar töflur þar sem hægt var að fletta upp gildum fyrir ýmis föll.
Það var tímafrekt og leiðinlegt að búa þessar töflur til og sumar þeirra innihéldu fullt af villum.

Ein fyrstu viðbrögðin við því þegar tölvur komu á sjónarsviðið voru:
``Þetta er frábært!  Við getum notað tölvurnar til að búa til töflur sem innihalda engar villur.''
Það reyndist vera (næstum því) rétt en skammsýnt.
Brátt urðu nefnilega tölvur og reiknivélar svo útbreiddar að það var engin þörf á þessum töflum lengur.

Jæja, næstum því.
Það vill reyndar svo að fyrir tilteknar aðgerðir nota tölvur töflur til að nálga svörin og nota síðan útreikninga til að bæta nálganirnar.
Í sumum tilvikum hafa verið villur í undirliggjandi töflum -- sú þekktasta í töflunni sem fyrsta útgáfa af Intel Pentium örgjörvanum notaði til að framkvæma kommutöludeilingu.

\index{deiling!kommutala}

Þrátt fyrir að ``log tafla'' sé ekki eins gagnleg og áður fyrr þá má nota hana sem gott dæmi um ítrun.
Eftirfarandi forrit skrifar út röð gilda í vinstri dálki og samsvarandi lógariþma í hægri dálki:

\begin{verbatim}
  double x = 1.0;
  while (x < 10.0) {
    cout << x << "\t" << log(x) << "\n";
    x = x + 1.0;
  }
\end{verbatim}
%
Stafarunan \verb+\t+ stendur fyrir {\bf dálkastafinn} (e. tab character).
Runan \verb+\n+ stendur fyrir {\bf newline} (ný lína) stafinn.
Báðar þessar runur er hægt að setja hvar sem er inn í streng en í þessu dæmi mynda runurnar heilan streng án nokkurra annara stafa.

Dálkastafurinn veldur því að bendillinn ``stekkur'' til hægri þangað til hann lendir á einum af {\bf dálkastoppum} (e. tab stops), sem erum yfirleitt eftir hverja átta stafi.

Eins og við sjáum hér rétt á eftir þá er dálkastafurinn hentugur til að skrifa út texta sem passar í dálka.

Stafurinn {\bf newline} virkar á nákvæmlega sama hátt og {\tt endl}, þ.e. veldur því að bendillinn hoppar í næstu línu fyrir neðan.
Ég nota yfirleitt {\tt endl} ef newline stafurinn stendur einn og sér en annars nota ég \verb+\n+ ef hann er hluti strengs.

Úttak þessa forrits er:

\begin{verbatim}
1      0
2      0.693147
3      1.09861
4      1.38629
5      1.60944
6      1.79176
7      1.94591
8      2.07944
9      2.19722
\end{verbatim}
%
Ef þér finnst þessi gildi vera undarleg, mundu þá að {\tt log} fallið notar grunn $e$.
Vegna þess hversu veldi af tveimur eru mikilvæg í tölvunarfræði þá viljum vio oft reikna út lógariþma með grunn 2.
Það getum við gert með því að nota eftirfarandi formúlu:

\[ \log_2 x = \frac {log_e x}{log_e 2} \]
%
Með því að breyta úttakssetningunni í 

\begin{verbatim}
      cout << x << "\t" << log(x) / log(2.0) << endl;
\end{verbatim}
%
þá fáum við:

\begin{verbatim}
1      0
2      1
3      1.58496
4      2
5      2.32193
6      2.58496
7      2.80735
8      3
9      3.16993
\end{verbatim}
%
Hér sjáum við að 1, 2, 4 og 8 eru veldi af tveimur vegna þess að lógariþminn með grunn 2 er heil tala.
Ef við vildum finna lógariþma af öðrum tölum af veldinu tveimur þá gætum við breytt forritinu á þennan hátt:

\begin{verbatim}
  double x = 1.0;
  while (x < 100.0) {
    cout << x << "\t" << log(x) / log(2.0) << endl;
    x = x * 2.0;
  }
\end{verbatim}
%
Í stað þess að bæta einhverju við {\tt x} í sérhverri ítrun lykkjunnar, og fáum þannig {\bf jafnmunarunu} (e. arithmetic sequence),
þá margföldum við {\tt x} með einhverju og fáum út {\bf kvótarunu} (e. geometric sequence).
Niðurstaðan er:

\begin{verbatim}
1      0
2      1
4      2
8      3
16     4
32     5
64     6
\end{verbatim}
%
Við notum dálkastafinn á milli dálka og því er staðsetning seinni dálksins ekki háð fjölda tölustafa í fyrri dálkinum.

Það má vera að log töflur séu ekki gagnlegar nú til dags en hins vegar er mikilvægt fyrir tölvunarfræðinga að þekkja veldi af tveimur!
Prófaðu að breyta forritinu þannig að það skrifi út veldi af tveimur upp í 65536 (þ.e. $2^{16}$).
Prentaðu það út og mundu það!


\section{Two-dimensional tables}
\index{table!two-dimensional}

A two-dimensional table is a table where you choose a row and
a column and read the value at the intersection.  A multiplication
table is a good example.  Let's say you wanted to print a
multiplication table for the values from 1 to 6.

A good way to start is to write a simple loop that prints
the multiples of 2, all on one line.

\begin{verbatim}
  int i = 1;
  while (i <= 6) {
    cout << 2*i << "   ";
    i = i + 1;
  }
  cout << endl;
\end{verbatim}
%
The first line initializes a variable named {\tt i}, which is
going to act as a counter, or {\bf loop variable}.  As the
loop executes, the value of {\tt i} increases from 1 to 6,
and then when {\tt i} is 7, the loop terminates.  Each
time through the loop, we print the value {\tt 2*i} followed
by three spaces.  By omitting the {\tt endl} from the
first output statement, we get 
all the output on a single line.

\index{loop variable}
\index{variable!loop}

The output of this program is:

\begin{verbatim}
2   4   6   8   10   12
\end{verbatim}
%
So far, so good.  The next step is to {\bf encapsulate} and {\bf
generalize}.

\section {Encapsulation and generalization}

Encapsulation usually means taking a piece of code and wrapping it up
in a function, allowing you to take advantage of all the things functions
are good for.  We have seen two examples of encapsulation, when we
wrote {\tt printParity} in Section~\ref{alternative} and {\tt
isSingleDigit} in Section~\ref{bool}.

Generalization means taking something specific, like printing
multiples of 2, and making it more general, like printing the
multiples of any integer.

\index{encapsulation}
\index{generalization}

Here's a function that encapsulates the loop from the previous
section and generalizes it to print multiples of {\tt n}.

\begin{verbatim}
void printMultiples (int n)
{
  int i = 1;
  while (i <= 6) {
    cout << n*i << "   ";
    i = i + 1;
  }
  cout << endl;
}
\end{verbatim}
%
To encapsulate, all I had to do was add the first line,
which declares the name, parameter,
and return type.  To generalize, all I had to do was replace
the value 2 with the parameter {\tt n}.

If we call this function with the argument 2, we get the same
output as before.  With argument 3, the output is:

\begin{verbatim}
3   6   9   12   15   18
\end{verbatim}
%
and with argument 4, the output is

\begin{verbatim}
4   8   12   16   20   24 
\end{verbatim}
%
By now you can probably guess how we are going to print a
multiplication table: we'll call {\tt printMultiples} repeatedly with
different arguments.  In fact, we are going to use another loop to
iterate through the rows.

\begin{verbatim}
  int i = 1;
  while (i <= 6) {
    printMultiples (i);
    i = i + 1;
  }    
\end{verbatim}
%
First of all, notice how similar this loop is to the one inside {\tt
printMultiples}.  All I did was replace the print statement with a
function call.

The output of this program is

\begin{verbatim}
1   2   3   4   5   6   
2   4   6   8   10   12   
3   6   9   12   15   18   
4   8   12   16   20   24   
5   10   15   20   25   30   
6   12   18   24   30   36   
\end{verbatim}
%
which is a (slightly sloppy) multiplication table.  If the
sloppiness bothers you, try replacing the spaces between
columns with tab characters and see what you get.

\section{Functions}
\index{function}

In the last section I mentioned ``all the things functions
are good for.''  About this time, you might be wondering
what exactly those things are.  Here are some of the reasons
functions are useful:

\begin{itemize}

\item By giving a name to a sequence of statements, you make
your program easier to read and debug.

\item Dividing a long program into functions allows you to
separate parts of the program, debug them in isolation, and
then compose them into a whole.

\item Functions facilitate both recursion and iteration.

\item Well-designed functions are often useful for many programs.
Once you write and debug one, you can reuse it.

\end{itemize}

\section{More encapsulation}
\index{encapsulation}
\index{program development!encapsulation}

To demonstrate encapsulation again, I'll take the code
from the previous section and wrap it up in a function:

\begin{verbatim}
void printMultTable () {
  int i = 1;
  while (i <= 6) {
    printMultiples (i);
    i = i + 1;
  }
}
\end{verbatim}
%
The process I am demonstrating is a common 
development plan.  You develop code gradually by adding
lines to {\tt main} or someplace else, and then when you get
it working, you extract it and wrap it up in a function.

The reason this is useful is that you sometimes don't know
when you start writing exactly how to divide the program into
functions.  This approach lets you design as you go along.

\section{Local variables}

About this time, you might be wondering how we can use the same
variable {\tt i} in both {\tt printMultiples} and {\tt
printMultTable}.  Didn't I say that you can only declare a variable
once?  And doesn't it cause problems when one of the functions changes
the value of the variable?

The answer to both questions is ``no,'' because the {\tt i} in {\tt
printMultiples} and the {\tt i} in {\tt printMultTable} are
{\em not the same variable}.  They have the same name, but
they do not refer to the same storage location, and changing
the value of one of them has no effect on the other.

\index{local variable}
\index{variable!local}

Remember that variables that are declared inside a function definition
are local.  You cannot access a local variable from outside its
``home'' function, and you are free to have multiple variables with
the same name, as long as they are not in the same function.

The stack diagram for this program shows clearly that the
two variables named {\tt i} are not in the same storage location.
They can have different values, and changing one does not affect
the other.

\vspace{0.1in}
\centerline{\epsfig{figure=stack4.eps}}
\vspace{0.1in}
%
Notice that the value of the parameter {\tt n} in
{\tt printMultiples} has to be the same as the value
of {\tt i} in {\tt printMultTable}.  On the other hand,
the value of {\tt i} in {\tt printMultiple} goes
from 1 up to {\tt n}.  In the diagram, it happens to be 3.
The next time through the loop it will be 4.

It is often a good idea to use different variable names in
different functions, to avoid confusion, but there are good
reasons to reuse names.  For example, it is common to
use the names {\tt i}, {\tt j} and {\tt k} as loop variables.
If you avoid using them in one function just because you
used them somewhere else, you will probably make the program
harder to read.

\index{loop variable}
\index{variable!loop}

\section{More generalization}
\index{generalization}

As another example of generalization, imagine you wanted
a program that would print a multiplication table of any
size, not just the 6x6 table.  You could add a parameter to
{\tt printMultTable}:

\begin{verbatim}
void printMultTable (int high) {
  int i = 1;
  while (i <= high) {
    printMultiples (i);
    i = i + 1;
  }
}
\end{verbatim}
%
I replaced the value 6 with the parameter {\tt high}.  If I
call {\tt printMultTable} with the argument 7, I get

\begin{verbatim}
1   2   3   4   5   6   
2   4   6   8   10   12   
3   6   9   12   15   18   
4   8   12   16   20   24   
5   10   15   20   25   30   
6   12   18   24   30   36   
7   14   21   28   35   42   
\end{verbatim}
%
which is fine, except that I probably want the table to
be square (same number of rows and columns), which means
I have to add another parameter to {\tt printMultiples},
to specify how many columns the table should have.

Just to be annoying, I will also call this parameter {\tt high},
demonstrating that different functions can have parameters
with the same name (just like local variables):

\begin{verbatim}
void printMultiples (int n, int high) {
  int i = 1;
  while (i <= high) {
    cout << n*i << "   ";
    i = i + 1;
  }    
  cout << endl;
}

void printMultTable (int high) {
  int i = 1;
  while (i <= high) {
    printMultiples (i, high);
    i = i + 1;
  }
}
\end{verbatim}
%
Notice that when I added a new parameter, I had to change the first
line of the function (the interface or prototype), and I also had to
change the place where the function is called in {\tt printMultTable}.
As expected, this program generates a square 7x7 table:

\begin{verbatim}
1   2   3   4   5   6   7   
2   4   6   8   10   12   14   
3   6   9   12   15   18   21   
4   8   12   16   20   24   28   
5   10   15   20   25   30   35   
6   12   18   24   30   36   42   
7   14   21   28   35   42   49
\end{verbatim}
%
When you generalize a function appropriately, you often find
that the resulting program has capabilities you did not intend.
For example, you might notice that the multiplication table
is symmetric, because $ab = ba$, so all the entries in the
table appear twice.  You could save ink by printing only
half the table.  To do that, you only have to change one
line of {\tt printMultTable}.  Change

\begin{verbatim}
      printMultiples (i, high);
\end{verbatim}
%
to

\begin{verbatim}
      printMultiples (i, i);
\end{verbatim}
%
and you get

\begin{verbatim}
1   
2   4   
3   6   9   
4   8   12   16   
5   10   15   20   25   
6   12   18   24   30   36   
7   14   21   28   35   42   49  
\end{verbatim}
%
I'll leave it up to you to figure out how it works.

\section{Glossary}

\begin{description}

\item[loop:]  A statement that executes repeatedly while a
condition is true or until some condition is satisfied.

\item[infinite loop:]  A loop whose condition is always true.

\item[body:]  The statements inside the loop.

\item[iteration:]  One pass through (execution of) the body
of the loop, including the evaluation of the condition.

\item[tab:] A special character, written as \verb+\t+ in C++,
that causes the cursor to move to the next tab stop on the
current line.

\item[encapsulate:]  To divide a large complex program into
components (like functions) and isolate the components from
each other (for example, by using local variables).

\item[local variable:]  A variable that is declared inside
a function and that exists only within that function.  Local variables
cannot be accessed from outside their home function, and do not
interfere with any other functions.

\item[generalize:]  To replace something unnecessarily specific
(like a constant value) with something appropriately general
(like a variable or parameter).  Generalization makes code more
versatile, more likely to be reused, and sometimes even easier
to write.

\item[development plan:]  A process for developing a program.
In this chapter, I demonstrated a style of development based on
developing code to do simple, specific things, and then encapsulating
and generalizing.

\index{loop}
\index{infinite loop}
\index{body}
\index{tab}
\index{loop!infinite}
\index{iteration}
\index{encapsulation}
\index{generalization}
\index{local variable}
\index{variable!local}
\index{program development}

\end{description}

