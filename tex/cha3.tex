% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

% This is an Icelandic translation/adaptation of the orginal book by Allen B. Downey

\chapter{Föll}

\section{Kommutölur}
\index{kommutölur}
\index{tag!double}
%\index{double (floating-point)}

Í síðasta kafla áttum við í nokkrum vandræðum með tölur sem eru ekki heiltölur.
Við leystum vandamálið að hluta til með því að reikna út prósentur í stað brots.
Almennari lausn er hins vegar að nota kommutölur (e. floating-point) sem geta staðið fyrir bæði brot og heiltölur.
Tvenns konar kommutölur eru í C++, {\tt float} og {\tt double}.
Í þessari bók munum við eingöngu nota {\tt double} tölur.

Þú getur búið til kommutölur og gefið þeim gildi með sömu málskipan og notuð er fyrir önnu tög.
Dæmi:

\begin{verbatim}
  double pi;
  pi = 3.14159;
\end{verbatim}
%
Það er einnig mögulegt að lýsa yfir breytu og gefa henni gildi á sama tíma:

\begin{verbatim}
  int x = 1;
  String empty = "";
  double pi = 3.14159;
\end{verbatim}
%
Reyndar vill svo til að þessi leið er mjög algeng.
Samsett yfirlýsing (e. declaration) og gildisveiting (e. asssignment) er stundum kölluð {\bf upphafsstilling} (e. initialization).

\index{upphafsstilling}

Þó svo að kommutölur séu nytsamlegar þá valda þær stundum ruglingi vegna þess að svo virðist sem heiltölur og kommutölur skarist. 
T.d., er gildið {\tt 1} heiltala, kommutala eða hvoru tveggja?

C++ gerir greinarmun á heiltölugildinu {\tt 1} og kommutölugildinu {\tt 1.0} þrátt fyrir að þau virðast standa fyrir sömu töluna.
Ástæðan er sú að gildin tvö tilheyra mismunandi tögum og almennt gildir að ekki er leyfilegt að framkvæma gildisveitingu ``á milli'' taga.
Þetta er t.d. ekki leyfilegt í C++

\begin{verbatim}
    int x = 1.1;
\end{verbatim}
%
vegna þess að breytan á vinstri hlið gildisveitingarinnar er af taginu {\tt int} og gildið á hægri hlið er {\tt double}.
Það er aftur á móti auðvelt að gleyma þessari reglu, sérstaklega vegna þess að í sumum tilvikum breytir C++ þýðandi einu tagi í annað á sjálfvirkan hátt.
T.d. ætti 

\begin{verbatim}
    double y = 1;
\end{verbatim}
%
tæknilega séð ekki að vera leyfilegt en C++ þýðandi leyfir þetta með því að breyta sjálfur
{\tt int} (gildinu 1) í {\tt double}.
Þessi ``linkind'' af hálfu þýðandans getur verið þægileg fyrir forritarann en getur jafnframt leitt til vandræða:
Dæmi:

\begin{verbatim}
    double y = 1 / 3;
\end{verbatim}
%
Hér gætir þú búist við því að breytan {\tt y} fái gildið {\tt 0.333333}, sem er leyfilegt kommutölugildi, en í raun fær hún gildið {\tt 0.0}.
Ástæðan er sú að segðin á hægri hlið gildisveitingarinnar er hlutfall tveggja heiltalna og því framkvæmir C++ {\em heiltöludeilingu}, hvers niðurstaða er heiltölugildið {\tt 0}.
Þegar því gildi er breytt (af þýðandanum) í kommutölu þá er niðurstaðan {\tt 0.0}.

Ein leið til að leysa þetta vandamál er að gera gildi segðarinnar á hægri hlið að kommutölu:

\begin{verbatim}
    double y = 1.0 / 3.0;
\end{verbatim}
%
Þetta veldur því að {\tt y} fær gildið {\tt 0.333333} eins og við var að búast.

\index{útreikningur!kommutala}

Allar þær reikniaðgerðir sem við höfum séð hingað til -- samlagning, frádráttur, margföldun og deiling -- virka á kommutölum sem og á heiltölum.
Það er hins vegar athyglisvert að undirliggjandi vélarmálsútreikningur er mismunandi eftir því hvort um kommutölur eða heiltölur er að ræða.
Flestir örgjörvar hafa einmitt sérstakan búnað til að framkvæma aðgerðir á kommutölum.

\section{Breyting á {\tt double} í {\tt int}}
\label{rounding}
\index{afrúnun}
\index{tagmótun}

Eins og ég nefndi áður þá breytir C++ þýðandinn {\tt int}
í {\tt double} á sjálfvirkan hátt ef þörf er á vegna þess að engar upplýsingar tapast í breytingunni.
Á hinn bóginn þá krefst breyting á {\tt double} í {\tt int} afrúnunar (e. rounding off).
C++ framkvæmir þá aðgerð ekki sjálfvirkt og því þarft þú, sem forritari, að vera meðvitaður um brotið sjálft (þ.e. sá hluti sem kemur á eftir kommunni) tapast.

Einfaldasta leiðin til að breyta kommutölu í heiltölu er að nota {\bf tagmótun} (e. typecast).
Tagmótun dregur nafn sitt af því að það gefur þér kost á því að ``móta'' gildi sem tilheyrir einu tagi yfir í annað tag.

Málskipan fyrir tagmótun er eins og málskipan fyrir fallakall.
Dæmi:

\begin{verbatim}
  double pi = 3.14159;
  int x = int (pi);
\end{verbatim}
%
{\tt int} fallið skilar heiltölu þannig að {\tt x} fær gildið 3.
Að móta kommutölu í heiltölu hefur í för með sér að talan er rúnuð niður (e. rounded down) jafnvel þó svo að brotið sé 0.99999999.

Fyrir sérhvert tag í C++ er til samsvarandi fall sem tagmótar sitt viðfang í viðeigandi tag.

\section{Stærðfræðiföll}
\index{Math function}
\index{fall!stærðfræði}
\index{segð}
\index{viðfang}

Í stærðfræði hefur þú væntanlega séð föll eins og $\sin$ and $\log$ og hefur lært að reikna út gildi segða eins og $\sin(\pi/2)$ og $\log(1/x)$.
Fyrst reiknar þú út gildi segðar innan sviga en það eru kallað {\bf viðfang} (e. argument) fallsins.
T.d. er $\pi/2$ u.þ.b. 1,571 og $1/x$ is 0,1 (ef $x$ hefur gildið 10).

Eftir þetta getur þú ákvarðar gildi fallsins sjálfs, annað hvort með því að fletta upp í töflu eða með því að framkvæma ýmsa útreikninga.
$\sin$ af 1,571 is 1 og $\log$ af 0,1 is -1 (ef við gerum ráð fyrir því að $\log$ standi fyrir 
lógariþma með grunn 10).

Þetta ferli er hægt að endurtaka til að ákvarða gildi flóknari segða eins og $\log(1/\sin(\pi/2))$.
Fyrst ákvörðum við gildi viðfangs innsta fallsins (þ.e. ($\pi/2$)), síðan reiknum við út gildi fallsins (þ.e. $\sin$), o.s.frv.

C++ býður upp á mengi af innbyggðum (e. built-in) föllum sem innihaldur flestar þær stærðfræðilegu aðgeðir sem þú getur ímyndað þér.
Kallað er á þessi stærðfræðiföll með því að nota málskipan sem er sambærileg við stærðfræðilega táknun: 

\begin{verbatim}
     double log = log (17.0);
     double angle = 1.5;
     double height = sin (angle);
\end{verbatim}
%
Fyrsta setningin að ofan gefur breytunni {\tt log} gildið lógariþmi af 17 (grunnur $e$).
Það er einnig til fall {\tt log10} sem reiknar út lógariþma miðað við grunn 10.

Þriðja setningin reiknar út sinus af gildinu sem geymt er í breytunni {\tt angle}.
C++ gerir ráð fyrir því að gildin sem notuð eru með sinus fallinu og öðrum hornaföllum ({\tt cos}, {\tt tan}) séu í {\em radian}.
Til að breyta gráðum í radian getur þú deilt með 360 og margfaldað með $2 \pi$.  

Ef þú þekkir ekki gildið á $\pi$ (með 15 aukastöfum!) þá getur þú reiknað það út með því að nota {\tt acos} fallið.
Arccosinus (eða andhverfa cosinus) af -1 er $\pi$ vegna þess að cosinus af $\pi$ er -1.

\begin{verbatim}
  double pi = acos(-1.0);
  double degrees = 90;
  double angle = degrees * 2 * pi / 360.0;
\end{verbatim}
%
Áður en þú getur notað eitthvað af stærðfræðiföllunum þarftu að taka inn (e. include) sérstaka {\bf hausaskrá} (e. header file) í forritið þitt.
Hausaskrá inniheldur upplýsingar um föll, sem eru skilgreind annars staðar en í þínu eigin forriti, og sem þýðandinn þarf á að halda.
Í ``Hello, world!'' forritunu tókum við t.d. inn haus nefndan {\tt iostream} með því að nota {\bf include} setningu:

\begin{verbatim}
#include <iostream>
using namespace std;
\end{verbatim}
%
{\tt iostream} inniheldur upplýsingar um inntaks- og úttaksstrauma (e. I/O streams), þ.m.t. um úttaksstrauminn {\tt cout}.
C++ notar öflugan eiginleika sem kallaður er {\bf nafnasvið} (e. namespaces) sem gerir þér t.d. kleift að útfæra {\tt cout} á þinn eigin máta.
Í flestum tilvikum notum við reyndar hina stöðluðu útfærslu sem skilgreind er í nafnasviðinu std.
Við látum þýðandann vita af þessu með línunni

\begin{verbatim}
using namespace std;
\end{verbatim}

Þumalputtareglan er sú að þú átt að skrifa {\tt using namespace std;} í hvert sinn sem þú ætlar að nota {\tt iostream}.

\index{header skrá}
\index{cmath}
\index{iostream}

Á sambærilegan hátt inniheldur {\tt cmath} hausaskráin upplýsingar um stærðfræðiföll.
Þú getur tekið þá skrá inn, ásamt {\tt iostream}, í upphafi forritsins þíns: 

\begin{verbatim}
#include <cmath>
\end{verbatim}

Hausaskrár sem byrja á `c' gefa til kynna að þær hafi upphaflega verið búnar til fyrir forritunarmálið {\bf C}.

\section {Samsetning}
\label{composition}
\index{samsetning}
\index{segð}

Föll í C++ geta verið samsett á sama hátt og stærðfræðiföll.
Þetta merkir að þú getur notað eina segð sem hluta af annarri.
Þú getur t.d. notað hvaða segð sem er sem viðfang í fall:

\begin{verbatim}
    double x = cos (angle + pi/2);
\end{verbatim}
%
Í þessari setningu er deilt í gildið {\tt pi} með tveimur og gildinu á breytunni {\tt angle} bætt við niðurstöðuna.
Summan er síðan send sem viðfang í fallið {\tt cos}.

Þú getur einnig sent niðurstöðuna úr eini falli sem viðfang í annað fall:

\begin{verbatim}
    double x = exp (log (10.0));
\end{verbatim}
%
Hér er tekinn lógariþmi (með grunn $e$) af 10 og niðurstaðan (nefnum hana $t$) síðan send inn í exp fallið sem reiknar $e$ í veldinu $t$.
Breytan {\tt x} fær að lokum gildið úr heildarniðurstöðunni sem ég vona að þú vitir hver er!

\section{Nýjum föllum bætt við}
\index{fall!skilgreining}
\index{main}
\index{fall!main}

Hingað til höfum við eingöngu notað föll sem eru innbyggð í C++ en við getum einnig bætt við nýjum föllum.
Reyndar vill svo til að við höfum þegar bætt við einu nýju falli: {\tt main}.
Fallið {\tt main} er sérstakt að því leyti til að það gefur til kynna hvar keyrsla forritsins á að byrja en málskipan fyrir {\tt main} er sú sama og fyrir hvaða aðra fallaskilgreiningu sem er:

\begin{verbatim}
  void NAFN ( LISTI AF VIÐFÖNGUM ) {
    SETNINGAR
  }
\end{verbatim}
%
Þú getur gefið fallinu þínu hvaða nafn sem er með þeirri undantekningu að þú getur hvorki kallað það 
{\tt main} né notað annað C++ lykilorð.
Listinn af viðföngum skilgreinir hvaða upplýsingar (ef nokkrar) þarf að gefa fallinu þegar það er notað (þegar {\bf kallað} (e. call)) er á það.

{\tt main} tekur engin viðföng eins og sjá má með tómum svigum {\tt ()} í skilgreiningunni á fallinu.
Fyrstu tvö föllin sem við munum skrifa taka heldur engin viðföng -- málskipanin lítur þá svona út:

\begin{verbatim}
  void newLine () {
    cout << endl;
  }
\end{verbatim}
%
This function is named {\tt newLine}; it contains only a single
statement, which outputs a newline character, represented by
the special value {\tt endl}.

In {\tt main} we can call this new function using syntax that
is similar to the way we call the built-in C++ commands:

\begin{verbatim}
int main ()
{
  cout << "First Line." << endl;
  newLine ();
  cout << "Second Line." << endl;
  return 0;
}
\end{verbatim}
%
The output of this program is

\begin{verbatim}
First line.

Second line.
\end{verbatim}
%
Notice the extra space between the two lines.  What if we wanted
more space between the lines?  We could call the same
function repeatedly:

\begin{verbatim}
int main ()
{
  cout << "First Line." << endl;
  newLine ();
  newLine ();
  newLine ();
  cout << "Second Line." << endl;
  return 0;
}
\end{verbatim}
%
Or we could write a new function, named {\tt threeLine}, that 
prints three new lines:

\begin{verbatim}
void threeLine ()
{
  newLine ();  newLine ();  newLine ();
}

int main ()
{
  cout << "First Line." << endl;
  threeLine ();
  cout << "Second Line." << endl;
  return 0;
}
\end{verbatim}
%
You should notice a few things about this program:

\begin{itemize}

\item You can call the same procedure repeatedly.  In
fact, it is quite common and useful to do so.

\item You can have one function call another function.  In this
case, {\tt main} calls {\tt threeLine} and {\tt threeLine}
calls {\tt newLine}.  Again, this is common and useful.

\item In {\tt threeLine} I wrote three statements all on the
same line, which is syntactically legal (remember that spaces
and new lines usually don't change the meaning of a program).
On the other hand, it is usually a better idea to put each
statement on a line by itself, to make your program easy to
read.  I sometimes break that rule in this book to save space.

\end{itemize}

So far, it may not be clear why it is worth the trouble to
create all these new functions.  Actually, there are a lot
of reasons, but this example only demonstrates two:

\begin{enumerate}

\item Creating a new function gives you an opportunity to
give a name to a group of statements.  Functions can simplify a program
by hiding a complex computation behind a single command, and by using
English words in place of arcane code.  Which is clearer, {\tt
newLine} or {\tt cout << endl}?

\item Creating a new function can make a program smaller by eliminating
repetitive code.  For example, a short way to print nine consecutive
new lines is to call {\tt threeLine} three times.  How would you
print 27 new lines?

\end{enumerate}

\section {Definitions and uses}

Pulling together all the code fragments from the previous
section, the whole program looks like this:

\begin{verbatim}
#include <iostream>
using namespace std;

void newLine ()
{
  cout << endl;
}

void threeLine ()
{
  newLine ();  newLine ();  newLine ();
}

int main ()
{
  cout << "First Line." << endl;
  threeLine ();
  cout << "Second Line." << endl;
  return 0;
}
\end{verbatim}

This program contains three function definitions: {\tt newLine},
{\tt threeLine}, and {\tt main}.

Inside the definition of {\tt main}, there is a statement that
uses or calls {\tt threeLine}.  Similarly, {\tt threeLine} calls
{\tt newLine} three times.  Notice that the definition of each
function appears above the place where it is used.

This is necessary in C++; the definition of a function must
appear before (above) the first use of the function.  You
should try compiling this program with the functions in a
different order and see what error messages you get.

\section {Programs with multiple functions}

When you look at a class definition that contains several functions, it
is tempting to read it from top to bottom, but that is likely to be
confusing, because that is not the {\bf order of execution} of the
program.

Execution always begins at the first statement of {\tt main},
regardless of where it is in the program (often it is at the bottom).
Statements are executed one at a time, in order, until you reach a
function call.  Function calls are like a detour in the flow of
execution.  Instead of going to the next statement, you go to the
first line of the called function, execute all the statements there,
and then come back and pick up again where you left off.

That sounds simple enough, except that you have to remember that one
function can call another.  Thus, while we are in the middle of {\tt
main}, we might have to go off and execute the statements in {\tt
threeLine}.  But while we are executing {\tt threeLine}, we get
interrupted three times to go off and execute {\tt newLine}.

Fortunately, C++ is adept at keeping track of where it is, so
each time {\tt newLine} completes, the program picks up where it left
off in {\tt threeLine}, and eventually gets back to {\tt main} so the
program can terminate.

What's the moral of this sordid tale?  When you read a program, don't
read from top to bottom.  Instead, follow the flow of execution.

\section {Parameters and arguments}
\index{parameter}
\index{argument}

Some of the built-in functions we have used have {\bf parameters},
which are values that you provide to let the function do its
job.  For example, if you want to find the sine of a number,
you have to indicate what the number is.  Thus, {\tt sin}
takes a {\tt double} value as a parameter.

Some functions take more than one parameter, like {\tt pow},
which takes two {\tt doubles}, the base and the exponent.

Notice that in each of these cases we have to specify not
only how many parameters there are, but also what type they
are.  So it shouldn't surprise you that when you write a
class definition, the parameter list indicates the type of
each parameter.  For example:

\begin{verbatim}
  void printTwice (char phil) {
    cout << phil << phil << endl;
  }
\end{verbatim}
%
This function takes a single parameter, named {\tt phil}, that
has type {\tt char}.  Whatever that parameter is (and at
this point we have no idea what it is), it gets printed
twice, followed by a newline.
I chose the name {\tt phil} to suggest that the name
you give a parameter is up to you, but in general you want to
choose something more illustrative than {\tt phil}.

In order to call this function, we have to provide a {\tt char}.
For example, we might have a {\tt main} function like this:

\begin{verbatim}
  int main () {
    printTwice ('a');
    return 0;
  }
\end{verbatim}
%
The {\tt char} value you provide is called an {\bf argument}, and we
say that the argument is {\bf passed} to the function.  In this
case the value {\tt 'a'} is passed as an argument
to {\tt printTwice} where it will get printed twice.

Alternatively, if we had a {\tt char} variable, we could
use it as an argument instead:

\begin{verbatim}
  int main () {
    char argument = 'b';
    printTwice (argument);
    return 0;
  }
\end{verbatim}
%
Notice something very important here: the name of the variable we pass
as an argument ({\tt argument}) has nothing to do with the name of the
parameter ({\tt phil}).  Let me say that again:

\begin{quote}

{\bf The name of the variable we pass as an argument has nothing to do
with the name of the parameter.}

\end{quote}

They can be the same or they can be different, but it is important
to realize that they are not the same thing, except that they happen
to have the same value (in this case the character {\tt 'b'}).

The value you provide as an argument must have the same type as
the parameter of the function you call.  This rule is
important, but it is sometimes confusing because C++ sometimes
converts arguments from one type to another automatically.  For
now you should learn the general rule, and we will deal with
exceptions later.

\section {Parameters and variables are local}

Parameters and
variables only exist inside their own functions.  Within the
confines of {\tt main}, there is no such thing as {\tt phil}.
If you try to use it, the compiler will complain.  Similarly,
inside {\tt printTwice} there is no such thing as {\tt argument}.

Variables like this are said to be {\bf local}.  In order to
keep track of parameters and local variables, it is useful to
draw a {\bf stack diagram}.  Like state diagrams, stack diagrams
show the value of each variable, but the variables are contained
in larger boxes that indicate which function they belong to.

For example, the state diagram for {\tt printTwice} looks 
like this:

\vspace{0.1in}
\centerline{\epsfig{figure=stack.eps}}
\vspace{0.1in}
%
Whenever a function is called, it creates a new {\bf instance}
of that function.  Each instance of a function contains the
parameters and local variables for that function.  In the
diagram an instance of a function is represented by a box
with the name of the function on the outside and the variables
and parameters inside.

In the example, {\tt main} has one local variable, {\tt argument}, and
no parameters.  {\tt printTwice} has no local variables and one
parameter, named {\tt phil}.

\section {Functions with multiple parameters}
\index{parameter!multiple}
\index{function!multiple parameter}
\index{class!Time}

The syntax for declaring and invoking functions with multiple
parameters is a common source of errors.  First, remember
that you have to declare the type of every parameter.  For
example

\begin{verbatim}
  void printTime (int hour, int minute) {
    cout << hour;
    cout << ":";
    cout << minute;
  }
\end{verbatim}
%
It might be tempting to write {\tt (int hour, minute)}, but
that format is only legal for variable declarations, not
for parameters.

Another common source of confusion is that you do not have
to declare the types of arguments.  The following is wrong!

\begin{verbatim}
    int hour = 11;
    int minute = 59;
    printTime (int hour, int minute);   // WRONG!
\end{verbatim}
%
In this case, the compiler can tell the type of {\tt hour}
and {\tt minute} by looking at their declarations.  It is
unnecessary and illegal to include the type when you pass them
as arguments.  The correct
syntax is {\tt printTime (hour, minute)}.

\section {Functions with results}
\index{fruitful function}
\index{function!fruitful}

You might have noticed by now that some of the functions we are using,
like the math functions, yield results.  Other functions,
like {\tt newLine}, perform an action but
don't return a value.  That raises some questions:

\begin{itemize}

\item What happens if you call a function and you don't
do anything with the result (i.e. you don't assign it to
a variable or use it as part of a larger expression)?

\item What happens if you use a function without a result as part
of an expression, like {\tt newLine() + 7}?

\item Can we write functions that yield results, or are we
stuck with things like {\tt newLine} and {\tt printTwice}?

\end{itemize}

The answer to the third question is ``yes, you can write functions that
return values,'' and we'll do it in a couple of chapters.  I will
leave it up to you to answer the other two questions by trying them
out.  Any time you have a question about what is legal or
illegal in C++, a good way to find out is to ask the compiler.

\section{Glossary}

\begin{description}

\item[floating-point:] A type of variable (or value) that can contain
fractions as well as integers.  There are a few floating-point types
in C++; the one we use in this book is {\tt double}.

\item[initialization:]  A statement that declares a new variable
and assigns a value to it at the same time.

\item[function:]  A named sequence of statements that performs some
useful function.  Functions may or may not take parameters, and may
or may not produce a result.

\item[parameter:]  A piece of information you provide
in order to call a function.  Parameters are like variables in
the sense that they contain values and have types.

\item[argument:]  A value that you provide when you call a
function.  This value must have the same type as the corresponding
parameter.

\item[call:]  Cause a function to be executed.

\index{floating-point}
\index{function}
\index{parameter}
\index{argument}
\index{call}
\index{initialization}

\end{description}

