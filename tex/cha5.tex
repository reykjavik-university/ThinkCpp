% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

% This is an Icelandic translation/adaptation of the orginal book by Allen B. Downey

\chapter{Föll sem skila gildi}

\section{Skilagildi}
\index{return}
\index{setning!return}
\index{fall!skilagildi}
%\index{fruitful function}
\index{skilagildi}
\index{void}
\index{fall!void}

Sum af þeim föllum sem við höfum notað, eins og t.d. stærðfræðiföllin, skila af sér einhverju gildi.
Tilgangurinn með því að kalla á þess konar fall er að búa til nýtt gildi sem er síðan notað til að gefa breytu gildi eða sem hluta af segð.
Dæmi:

\index{stærðfræðifall!exp}
\index{stærðfræðifall!sin}

\begin{verbatim}
  double e = exp (1.0);
  double height = radius * sin (angle);
\end{verbatim}
%
Hins vegar vill svo til að öll þau föll sem við höfum sjálf skrifað hingað til eru {\bf void} föll, þ.e. föll sem skila ekki neinu gildi.
Kall í void fall er yfirleitt gert án nokkurrar gildisveitingar (því ekkert gildi kemur til baka úr fallinu!):

\begin{verbatim}
  nLines (3);
  countdown (n-1);
\end{verbatim}
%
Í þessum kafla munum við skrifa föll sem skila af sér gildum.
Það mætti segja að þessi föll beri ávöxt!
Fyrsta dæmið er {\tt area}, sem tekur {\tt double} sem viðfang, og skilar flatarmáli hrings með gefinn radíus:

\index{stærðfræðifall!acos}
\index{pi}

\begin{verbatim}
double area (double radius) {
  double pi = acos (-1.0);
  double area = pi * radius * radius;
  return area;
}
\end{verbatim}
%
Það fyrsta sem þú ættir að taka eftir er að byrjun fallaskilgreiningarinnar er öðruvísi.
Í stað {\tt void}, sem gefur til kynna void fall, þá sjáum við hér {\tt double} sem gefur til kynna að skilagildið úr þessu falli sé af taginu {\tt double}.

Taktu líka eftir að síðasta línan í fallinu er önnur útgáfa af {\tt return} setningu sem inniheldur skilagildi.
Þessi setning þýðir ``hætta strax keyrslu þessa falls og nota eftirfarandi segð sem skilagildið.''
Segðin. sem kemur á eftir lykilorðinu return. getur verið eins flókin og verða vill þannig að við gætum hafa skrifað fallið á samþjappaðri hátt:

\begin{verbatim}
double area (double radius) {
  return acos(-1.0) * radius * radius;
}
\end{verbatim}
%
Á hinn bóginn má segja að, {\bf tímabundnar} (e. temporary) breytur eins og {\tt area} gera kembingu oft auðveldari.
Í báðum tilvikum þarf tag segðarinnar í return setningunni að passa við skilatag fallsins.
M.ö.o., þegar þú skilgreinir að skilagildið sé af taginu {\tt double} þá ert ``lofar'' þú því að fallið muni að endingu skila {\tt double}.
Þýðandinn mun kvarta ef þú reynir að skila engri segð eða segð af röngu tagi. 

\index{tímabundin breyta}
\index{breyta!tímabundin}

Stundum getur verið hentug að hafa margar return setningar í falli -- eina fyrir sérhverja kvísl í skilyrðissetningu:Sometimes it is useful to have multiple return

\begin{verbatim}
double absoluteValue (double x) {
  if (x < 0) {
    return -x;
  } else {
    return x;
  }
}
\end{verbatim}
%
Aðeins ein af þessum return setningum mun verða keyrð þar sem return setningarnar eru í mismunandi kvíslum.
Þrátt fyrir að það sé leyfilegt að hafa fleiri en eina {\tt return} setningu í falli þá skaltu muna að um leið og ein þeirra er keyrð þá hættir fallið keyrslu og mun ekki keyra þær setningar sem á eftir koma.

Kóði sem kemur á eftir {\tt return} setningu, eða á stað sem flæðið mun ekki komast í, er kallaður {\bf dauður kóði} (e. dead code).
Sumir þýðendur gefa einmitt aðvaranir ef hluti kóða er ``dauður''.

\index{dauður kóði}

Ef þú setur return setningu innan í skilyrðissetningu þá þarftu að sjá til þess að {\em sérhver möguleg leið} gegnum forritið lendi að lokum á return setningu.
Dæmi: 

\begin{verbatim}
double absoluteValue (double x) {
  if (x < 0) {
    return -x;
  } else if (x > 0) {
    return x;
  }                          // WRONG!!
}
\end{verbatim}
%
Þetta forrit er ekki rétt vegna þess að ef {\tt x} er 0 þá er hvorugt skilyrðanna satt og fallið mun þá hætta keyrslu án þess að framkvæma return setningu. then
Því miður þá grípa ekki allir C++ þýðendur þessa villu.
Því má vera að forritið þýðist og keyrist en þegar {\tt x==0} þá getur skilagildið í raun verið hvað sem er og líklega mismunandi eftir ólíkum umhverfum.

\index{tölugildi}
\index{villa!á þýðandatíma}
%\index{compile-time error}

Núna ert þú líklega orðin(n) hundleið(ur) á þýðandavillum en eftir því sem reynslan eykst þá áttar þú þig á því 
að það eina sem er verra en að fá þýðandavillu er að fá {\em ekki} þýðandavillu þegar forritið er ekki rétt!

Hér er dæmi um eitthvað sem gæti gerst: Þú prófar {\tt absoluteValue} með ýmsum mismunandi gildum á {\tt x} og það virðist virka rétt.
Þú lætur síðan einhvern annan fá forritið og viðkomandi prófar það í öðru umhverfi.
Á einhvern dularfullan hátt skilar það ekki réttu gildi og eftir nokkra daga kembingu kemstu að því að útfærslan á {\tt absoluteValue} er ekki rétt.
Bara ef þýðandinn hefði aðvarað þig!

%\index{compile-time error}
%\index{error!compile-time}
\index{aflúsun}
\index{kembing}

Framvegis skaltu ekki álasa þýðandanum ef hann bendir á villu í forritinu þínu.
Þú skalt frekar þakka honum fyrir a finna villu og spara þér nokkrar daga vinnu við aflúsun.
Sumum þýðendur hafa valkost sem segir þeiim að vera sérstaklega ``strangur'' og greina frá öllum villum sem þeir finna.
Þú ættir alltaf að velja þennan valkost í þínum þýðanda.

\index{stærðfræðifall!fabs}

Sem innskot þá bendi ég á að það er fall í math safninu sem heitir {\tt fabs}.
Það reiknar tölugildið á {\tt double} -- á réttan hátt.

\section{Þróun forrits}
\label{distance}
\index{þróun forrits}

Á þessum tímapunkti ættir þú að geta skoðað C++ föll í heild sinni og sagt til um hvað þau gera.
Aftur á móti er þér kannski ekki ljóst hvernig eigi að skrifa þau.
Ég mun núna stinga upp á einni aðferð við þróun forrits sem ég kalla {\bf stigvaxandi þróun} (e. incremental development).

\index{stigvaxandi þróun}
\index{þróun forrits}

Gefum okkur t.d. að þú þurfir að skrifa fall sem reiknar fjarlægðina á milli tveggja punkta sem gefnir eru með hitunum $(x_1, y_1)$ og $(x_2, y_2)$.
Hefðbundna skilgreiningin á fjarlægð tveggja punkta er:

\begin{equation}
distance = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\end{equation}
%
Fyrsta skrefið er að íhuga hvernig {\tt distance} fall ætti að líta út í C++.
M.ö.o., hvert er inntakið (leppar/viðföng) og hvert er úttakið (return gildið).

Í þessu tilvik eru punktarnir tveir auðvitað viðföngin inn í fallið og það er eðlilegt að nota fjóra leppa af taginu {\tt double}.
Skilagildið er fjarlægð sem er líka eðlilegt að beri tagið {\tt double}.

Nú þegar getum við því skrifað drög að fallinu:

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  return 0.0;
}
\end{verbatim}
%
{\tt Return} setningin er þarna að forminu til svo að fallið þýðist og keyri þrátt fyrir að setningin skili ekki réttu gildi.
Á þessu stigi gerir fallið í raun ekkert gagnlegt en það er þess virði að reyna að þýða það strax svo við getum fundið málskipunarvillur áður en fallið verður flóknara.

Til að prófa nýja fallið verðum við að kalla á það með einhverjum tilraunagildum (viðföngum).
Einhversstaðar í {\tt main} myndi ég bæta við:

\begin{verbatim}
  double dist = distance (1.0, 2.0, 4.0, 6.0);
  cout << dist << endl;
\end{verbatim}
%
Ég valdi gildin þannig að lárétta fjarlægðin er 3 og lóðrétta fjarlægðin er 4.
Þá ætti niðurstaðan að vera 5 (langhliðin í 3-4-5 þríhyrningi).
Það er gagnlegt að vita rétta svarið þegar maður prófar fall!

Þegar við höfum athugað að málskipanin í fallaskilgreiningunni okkar er rétt getum við byrjað á því að bæta við setningum í fallið, einni í einu.
Svo þýðum við og keyrum forritið eftir sérhverja (stigvaxandi) breytingu.
Ef villa kemur upp þá vitum við nákvæmlega hvar hún er -- í síðustu línunni sem við bættum við.

Næsta skref í útreikningnum okkar er að finna mismuninn á $x_2 - x_1$ og $y_2 - y_1$.
Ég mun geyma þessi gildi (milliniðurstöður) í tímabundnum breytum sem ég nefni {\tt dx} og {\tt dy}.

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  double dx = x2 - x1;
  double dy = y2 - y1;
  cout << "dx is " << dx << endl;
  cout << "dy is " << dy << endl;
  return 0.0;
}
\end{verbatim}
%
Ég bætti við úttakssetningum sem skrifa út gildin á tímabundnu breytunum. 
Eins og ég nefndi að ofan þá veit ég þegar að þessi gildi ættu að vera 3,0 og 4,0.

\index{stoðbúnaður}

Ég mun síðan fjarlægja þessar úttakssetningar þegar ég hef lokið við þróun fallsins.
Kóði eins og þessi er einsskonar {\bf stoðbúnaður} (e. scaffolding) vegna þess að hann hjálpar til við þróun fallsins en er ekki hluti af endanlegri útgáfu þess.

Stundum er reyndar gott að fjarlægja ekki stoðbúnaðinn algerlega heldur setja hann inn í athugasemdir (e. comments) ef ske kynni að við þyrftum á honum að halda síðar.

Næsta skref í þróun fallsins er þá að setja {\tt dx} og {\tt dy} í annað veldi og leggja niðurstöðurnar saman.
Við gætum notað {\tt pow} fallið en það er einfaldara og fljótvirkara að margfalda hvorn liðinn með sjálfu sér.

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  double dx = x2 - x1;
  double dy = y2 - y1;
  double dsquared = dx*dx + dy*dy;
  cout << "dsquared is " << dsquared;
  return 0.0;
}
\end{verbatim}
%
Hér myndi ég aftur þýða og keyra forritið og athuga milliniðurstöðuna (tímabundna gildið) sem ætti að vera 25,0.

Að lokum notum við {\tt sqrt} fallið til að reikna og skila lokaniðurstöðunni.

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  double dx = x2 - x1;
  double dy = y2 - y1;
  double dsquared = dx*dx + dy*dy;
  double result = sqrt (dsquared);
  return result;
}
\end{verbatim}
%
Í {\tt main} ættum við síðan að skrifa út og athuga gildið sem við fáum til baka úr kallinu á fallið distance.

Eftir því sem reynslan þín eykst þá muntu skrifa og kemba fleiri en eina línu í einu.
Samt sem áður mun þetta stigvaxandi þróunarferli spara þér mikinn tíma við kembingu síðar meir.

Megin þættir í þessu ferli eru:

\begin{itemize}

\item Byrjaðu með forrit sem keyrir og gerðu litlar, stigvaxtandi breytingar.
Ef einhver villa kemur upp þá veistu nákvæmlega hvar hún er.

\item Notaðu tímabundnar breytur til að geyma milliniðurstöður þannig að þú getir skrifað þær út.

\item Þegar forritið er tilbúið þá viltu kannski fjarlægja stoðbúnaðinn eða skipta mörgum setningum út fyrir samsettar segðir (e. compound expressions), en þó aðeins ef það gerir forritið þitt ekki ólæsilegra.

\end{itemize}

\section{Samsetning}
\index{samsetning}

Þegar þú hefur skilgreint nýtt fall þá getur þú notað það sem hluta af segð og þú getur einnig skilgreint ný föll með því að nota þau föll sem eru þegar til.
Hvað ef t.d. einhver gæfi þér tvo punkta, miðju hrings og punkt á hringnum, og spyrði um flatarmál hringsins?

Gefum okkur að miðjan sé geymd í breytunum {\tt xc} og {\tt yc} og punkturinn á hringnum í {\tt xp} og {\tt yp}.
Fyrsta skrefið er þá að finna radíus hringsins, þ.e. fjarlægðina á milli punktanna tveggja.
Við eigum einmitt fall, {\tt distance}, sem gerir það!

\begin{verbatim}
  double radius = distance (xc, yc, xp, yp);
\end{verbatim}
%
Næsta skref er síðan að finna flatarmál hrings með þennan radíus og skila því.

\begin{verbatim}
  double result = area (radius);
  return result;
\end{verbatim}
%
Ef við setjum þennan kóða inn í sér fall þá fáum við:

\begin{verbatim}
double fred (double xc, double yc, double xp, double yp) {
  double radius = distance (xc, yc, xp, yp);
  double result = area (radius);
  return result;
} 
\end{verbatim}
%
Nafnið á þessu falli er {\tt fred} sem er vissulega skrýtið.
Í næsta kafla mun ég skýra út af hverju nanfið er undarlegt.

Tímabundnu breyturnar {\tt radius} og {\tt area} eru gagnlegar í þróuninni og í kembun 
en þegar við erum viss um að fallið virki þá getum skrifað það á samþjappaðra hátt með því að setja saman fallaköllin tvö:

\begin{verbatim}
double fred (double xc, double yc, double xp, double yp) {
  return area (distance (xc, yc, xp, yp));
} 
\end{verbatim}

\section{Overloading}
\label{overloading}
\index{overloading}

In the previous section you might have noticed that {\tt fred}
and {\tt area} perform similar functions---finding
the area of a circle---but take different parameters.  For
{\tt area}, we have to provide the radius; for {\tt fred}
we provide two points.

If two functions do the same thing, it is natural to give them
the same name.  In other words, it would make more sense if
{\tt fred} were called {\tt area}.

Having more than one function with the same name, which is called {\bf
overloading}, is legal in C++ {\em as long as each version takes
different parameters}.  So we can go ahead and rename {\tt fred}:

\begin{verbatim}
double area (double xc, double yc, double xp, double yp) {
  return area (distance (xc, yc, xp, yp));
} 
\end{verbatim}
%
This looks like a recursive function, but it is not.  Actually,
this version of {\tt area} is calling the other version.
When you call an overloaded function, C++ knows which version you
want by looking at the arguments that you provide.  If you write:

\begin{verbatim}
    double x = area (3.0);
\end{verbatim}
%
C++ goes looking for a function named {\tt area} that
takes a {\tt double} as an argument, and so it uses the
first version.  If you write

\begin{verbatim}
    double x = area (1.0, 2.0, 4.0, 6.0);
\end{verbatim}
%
C++ uses the second version of {\tt area}.  

Many of the built-in C++ commands are overloaded, meaning that there
are different versions that accept different numbers or types of
parameters.

Although overloading is a useful feature, it should be used with
caution.  You might get yourself nicely confused if you are trying to
debug one version of a function while accidently calling a different
one.

Actually, that reminds me of one of the cardinal rules of debugging:
{\bf make sure that the version of the program you are looking at is
the version of the program that is running!}  Some time you may find
yourself making one change after another in your program, and seeing
the same thing every time you run it.  This is a warning sign that for
one reason or another you are not running the version of the program
you think you are.  To check, stick in an output statement (it
doesn't matter what it says) and make sure the behavior of the
program changes accordingly.

\section{Boolean values}
\index{boolean}
\index{value!boolean}

The types we have seen so far are pretty big.  There are a lot
of integers in the world, and even more floating-point numbers.
By comparison, the set of characters is pretty small.  Well, there
is another type in C++ that is even smaller.  It is called
{\bf boolean}, and the only values in it are
{\tt true} and {\tt false}.

Without thinking about it, we have been using boolean values for the
last couple of chapters.  The condition inside an {\tt if}
statement or a {\tt while} statement is a boolean expression.
Also, the result of a comparison operator is a boolean value.
For example:

\begin{verbatim}
  if (x == 5) {
    // do something
  }
\end{verbatim}
%
The operator {\tt ==} compares two integers and produces a
boolean value.

\index{operator!comparison}
\index{comparison operator}

The values {\tt true} and {\tt false} are keywords in C++,
and can be used anywhere a boolean expression is called for.
For example, 

\begin{verbatim}
  while (true) {
    // loop forever
  }
\end{verbatim}
%
is a standard idiom for a loop that should run forever (or
until it reaches a {\tt return} or {\tt break} statement).

\section{Boolean variables}
\index{type!{\tt bool}}

As usual, for every type of value, there is a corresponding
type of variable.  In C++ the boolean type is called {\bf bool}.
Boolean variables work just like the other types:

\begin{verbatim}
  bool fred;
  fred = true;
  bool testResult = false;
\end{verbatim}
%
The first line is a simple variable declaration;
the second line is an assignment, and the third line is a
combination of a declaration and as assignment, 
called an initialization.

\index{initialization}
\index{statement!initialization}

As I mentioned, the result of a comparison operator is a boolean,
so you can store it in a {\tt bool} variable

\begin{verbatim}
  bool evenFlag = (n%2 == 0);     // true if n is even
  bool positiveFlag = (x > 0);    // true if x is positive
\end{verbatim}
%
and then use it as part of a conditional statement later

\begin{verbatim}
  if (evenFlag) {
    cout << "n was even when I checked it" << endl;
  }
\end{verbatim}
%
A variable used in this way is called a {\bf flag},
since it flags the presence or absence of some condition.

\index{flag}

\section{Logical operators}
\index{logical operator}
\index{operator!logical}

There are three {\bf logical operators} in C++: AND, OR and NOT,
which are denoted by the symbols {\tt \&\&}, {\tt ||} and
{\tt !}.  The semantics (meaning) of these operators is similar
to their meaning in English.  For example {\tt x > 0 \&\& x < 10}
is true only if {\tt x} is greater than zero AND less than 10.

\index{semantics}

{\tt evenFlag || n\%3 == 0} is true if {\em either} of
the conditions is true, that is, if {\tt evenFlag} is true OR the
number is divisible by 3.

Finally, the NOT operator has the effect of negating or
inverting a bool expression, so {\tt !evenFlag} is true
if {\tt evenFlag} is false; that is, if the number is odd.

\index{nested structure}

Logical operators often provide a way to simplify nested
conditional statements.  For example, how would you write
the following code using a single conditional?

\begin{verbatim}
  if (x > 0) {
    if (x < 10) {
      cout << "x is a positive single digit." << endl;
    }
  }
\end{verbatim}

\section{Bool functions}
\label{bool}
\index{bool}
\index{function!bool}

Functions can return {\tt bool} values just like any other type,
which is often convenient for hiding complicated tests inside
functions.  For example:

\begin{verbatim}
bool isSingleDigit (int x)
{
  if (x >= 0 && x < 10) {
    return true;
  } else {
    return false;
  }
}
\end{verbatim}
%
The name of this function is {\tt isSingleDigit}.  It is common
to give boolean functions names that sound like yes/no questions.
The return type is {\tt bool}, which means that every return
statement has to provide a {\tt bool} expression.

The code itself is straightforward, although it is a bit longer than
it needs to be.  Remember that the expression {\tt x >= 0 \&\& x < 10}
has type {\tt bool}, so there is nothing wrong with returning it
directly, and avoiding the {\tt if} statement altogether:

\begin{verbatim}
bool isSingleDigit (int x)
{
  return (x >= 0 && x < 10);
}
\end{verbatim}
%
In {\tt main} you can call this function in the usual ways:

\begin{verbatim}
  cout << isSingleDigit (2) << endl;
  bool bigFlag = !isSingleDigit (17);
\end{verbatim}
%
The first line outputs the value {\tt true} because 2 is a
single-digit number.  Unfortunately, when C++ outputs {\tt bool}s, it
does not display the words {\tt true} and {\tt false}, but rather the
integers {\tt 1} and {\tt 0}.\footnote{There is a way to fix that
using the {\tt boolalpha} flag, but it is too hideous to mention.}

The second line assigns the value {\tt true} to {\tt bigFlag}
only if 17 is {\em not} a single-digit number.

The most common use of {\tt bool} functions is inside conditional
statements

\begin{verbatim}
  if (isSingleDigit (x)) {
    cout << "x is little" << endl;
  } else {
    cout << "x is big" << endl;
  }
\end{verbatim}

\section {Returning from {\tt main}}

Now that we have functions that return values, I can let you in
on a secret.  {\tt main} is not really supposed to be a {\tt void}
function.  It's supposed to return an integer:

\begin{verbatim}
int main ()
{
  return 0;
}  
\end{verbatim}
%
The usual return value from {\tt main} is 0, which indicates that
the program succeeded at whatever it was supposed to to.  If something
goes wrong, it is common to return -1, or some other value that
indicates what kind of error occurred.

Of course, you might wonder who this value gets returned to, since
we never call {\tt main} ourselves.  It turns out that when the
system executes a program, it starts by calling {\tt main}
in pretty much the same way it calls all the other functions.

There are even some parameters that are passed to {\tt main}
by the system, but we are not going to deal with them for a little
while.

\section {More recursion}
\index{recursion}
\index{language!complete}

So far we have only learned a small subset of C++, but you
might be interested to know that this subset is now
a {\bf complete} programming language, by which I
mean that anything that can be computed can be expressed in this
language.  Any program ever written could be rewritten
using only the language features we have used so far (actually, we
would need a few commands to control devices like the keyboard, mouse,
disks, etc., but that's all).

\index{Turing, Alan}

Proving that claim is a non-trivial exercise first
accomplished by Alan Turing, one of the first computer scientists
(well, some would argue that he was a mathematician, but a lot of the
early computer scientists started as mathematicians).  Accordingly, it
is known as the Turing thesis.  If you take a course on the Theory of
Computation, you will have a chance to see the proof.

To give you an idea of what you can do with the tools we have learned
so far, we'll evaluate a few recursively-defined
mathematical functions.  A recursive definition is similar to a
circular definition, in the sense that the definition contains a
reference to the thing being defined.  A truly circular definition is
typically not very useful:

\begin{description}

\item[frabjuous:] an adjective used to describe
something that is frabjuous.

\index{frabjuous}

\end{description}

If you saw that definition in the dictionary, you might be
annoyed.  On the other hand, if you looked up the definition
of the mathematical function {\bf factorial}, you might
get something like:

\begin{eqnarray*}
&&  0! = 1 \\
&&  n! = n \cdot (n-1)!
\end{eqnarray*}

(Factorial is usually denoted with the symbol $!$, which is
not to be confused with the C++ logical operator {\tt !} which
means NOT.)  This definition says that the factorial of 0 is 1,
and the factorial of any other value, $n$, is $n$ multiplied
by the factorial of $n-1$.  So $3!$ is 3 times $2!$, which is 2 times
$1!$, which is 1 times 0!.  Putting it all together, we get
$3!$ equal to 3 times 2 times 1 times 1, which is 6.

If you can write a recursive definition of something, you can usually
write a C++ program to evaluate it.  The first step is to decide what
the parameters are for this function, and what the return type is.
With a little thought, you should conclude that factorial takes an
integer as a parameter and returns an integer:

\begin{verbatim}
int factorial (int n)
{
}
\end{verbatim}
%
If the argument happens to be zero, all we have to do is
return 1:

\begin{verbatim}
int factorial (int n)
{
  if (n == 0) {
    return 1;
  }
}
\end{verbatim}
%
Otherwise, and this is the interesting part, we have to make
a recursive call to find the factorial of $n-1$, and then
multiply it by $n$.

\begin{verbatim}
int factorial (int n)
{
  if (n == 0) {
    return 1;
  } else {
    int recurse = factorial (n-1);
    int result = n * recurse;
    return result;
  }
}
\end{verbatim}
%
If we look at the flow of execution for this program,
it is similar to {\tt nLines} from the previous chapter.
If we call {\tt factorial} with the value 3:

Since 3 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 2 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 1 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 0 {\em is} zero, we take the first branch and return
the value 1 immediately without making any more recursive
calls.

\end{quote}

The return value (1) gets multiplied by {\tt n}, which is 1,
and the result is returned.

\end{quote}

The return value (1) gets multiplied by {\tt n}, which is 2,
and the result is returned.

\end{quote}

\noindent The return value (2) gets multiplied by {\tt n}, which is 3,
and the result, 6, is returned to {\tt main}, or whoever
called {\tt factorial (3)}.

\index{stack}
\index{diagram!state}
\index{diagram!stack}

Here is what the stack diagram looks like for this sequence of
function calls:

\vspace{0.1in}
\centerline{\epsfig{figure=stack3.eps}}
\vspace{0.1in}
%
The return values are shown being passed back up the stack.

Notice that in the last instance of {\tt factorial}, the local
variables {\tt recurse} and {\tt result} do not exist because
when {\tt n=0} the branch that creates them does not execute.

\section{Leap of faith}
\index{leap of faith}

Following the flow of execution is one way to read programs, but as
you saw in the previous section, it can quickly become labarynthine.
An alternative is what I call the ``leap of faith.''  When you come to
a function call, instead of following the flow of execution, you
{\em assume} that the function works correctly and returns the
appropriate value.

In fact, you are already practicing this leap of faith
when you use built-in functions.  When you call {\tt cos}
or {\tt exp}, you don't examine the implementations of 
those functions.  You just assume that they work, because the people
who wrote the built-in libraries were good programmers.

Well, the same is true when you call one of your own functions.
For example, in Section~\ref{bool} we wrote a function called
{\tt isSingleDigit} that determines whether a number is between
0 and 9.  Once we have convinced ourselves that this function
is correct---by testing and examination of the code---we can
use the function without ever looking at the code again.

The same is true of recursive programs.  When you get to the recursive
call, instead of following the flow of execution, you should {\em
assume} that the recursive call works (yields the correct result), and
then ask yourself, ``Assuming that I can find the factorial of $n-1$,
can I compute the factorial of $n$?''  In this case, it is clear that
you can, by multiplying by $n$.

Of course, it is a bit strange to assume that the function works
correctly when you have not even finished writing it, but that's why
it's called a leap of faith!

\section{One more example}
\index{factorial}

In the previous example I used temporary variables to spell out the
steps, and to make the code easier to debug, but I could have saved a
few lines:

\begin{verbatim}
int factorial (int n) {
  if (n == 0) {
    return 1;
  } else {
    return n * factorial (n-1);
  }
}
\end{verbatim}
%
From now on I will tend to use the more concise version, but
I recommend that you use the more explicit version while you
are developing code.   When you have it working, you can
tighten it up, if you are feeling inspired.

After {\tt factorial}, the classic example of a recursively-defined
mathematical function is {\tt fibonacci}, which has the
following definition:

\begin{eqnarray*}
&& fibonacci(0) = 1 \\
&& fibonacci(1) = 1 \\
&& fibonacci(n) = fibonacci(n-1) + fibonacci(n-2);
\end{eqnarray*}
%
Translated into C++, this is

\begin{verbatim}
int fibonacci (int n) {
  if (n == 0 || n == 1) {
    return 1;
  } else {
    return fibonacci (n-1) + fibonacci (n-2);
  }
}
\end{verbatim}
%
If you try to follow the flow of execution here, even for fairly small
values of {\tt n}, your head explodes.  But according to the leap of
faith, if we assume that the two recursive calls (yes, you can make
two recursive calls) work correctly, then it is clear that we get the
right result by adding them together.

\section{Glossary}

\begin{description}

\item[return type:]  The type of value a function returns.

\item[return value:]  The value provided as the result of a function
call.

\item[dead code:]  Part of a program that can never be executed,
often because it appears after a {\tt return} statement.

\item[scaffolding:]  Code that is used during program development
but is not part of the final version.

\item[void:]  A special return type that indicates a void function;
that is, one that does not return a value.

\item[overloading:]  Having more than one function with the same name
but different parameters.  When you call an overloaded function,
C++ knows which version to use by looking at the arguments you
provide.

\item[boolean:]  A value or variable that can take on one of
two states, often called $true$ and $false$.  In C++, boolean
values can be stored in a variable type called {\tt bool}.

\item[flag:]  A variable (usually type {\tt bool}) that records
a condition or status information.

\item[comparison operator:]  An operator that compares two values
and produces a boolean that indicates the relationship between the
operands.

\item[logical operator:]  An operator that combines boolean values
in order to test compound conditions.

\index{return type}
\index{return value}
\index{dead code}
\index{scaffolding}
\index{void}
\index{overloading}
\index{bool}
\index{operator!conditional}
\index{operator!logical}

\end{description}

