% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

% This is an Icelandic translation/adaptation of the orginal book by Allen B. Downey

\chapter{Föll sem skila gildi}

\section{Skilagildi}
\index{return}
\index{setning!return}
\index{fall!skilagildi}
%\index{fruitful function}
\index{skilagildi}
\index{void}
\index{fall!void}

Sum af þeim föllum sem við höfum notað, eins og t.d. stærðfræðiföllin, skila af sér einhverju gildi.
Tilgangurinn með því að kalla á þess konar fall er að búa til nýtt gildi sem er síðan notað til að gefa breytu gildi eða sem hluta af segð.
Dæmi:

\index{stærðfræðifall!exp}
\index{stærðfræðifall!sin}

\begin{verbatim}
  double e = exp (1.0);
  double height = radius * sin (angle);
\end{verbatim}
%
Hins vegar vill svo til að öll þau föll sem við höfum sjálf skrifað hingað til eru {\bf void} föll, þ.e. föll sem skila ekki neinu gildi.
Kall í void fall er yfirleitt gert án nokkurrar gildisveitingar (því ekkert gildi kemur til baka úr fallinu!):

\begin{verbatim}
  nLines (3);
  countdown (n-1);
\end{verbatim}
%
Í þessum kafla munum við skrifa föll sem skila af sér gildum.
Það mætti segja að þessi föll beri ávöxt!
Fyrsta dæmið er {\tt area}, sem tekur {\tt double} sem viðfang, og skilar flatarmáli hrings með gefinn radíus:

\index{stærðfræðifall!acos}
\index{pi}

\begin{verbatim}
double area (double radius) {
  double pi = acos (-1.0);
  double area = pi * radius * radius;
  return area;
}
\end{verbatim}
%
Það fyrsta sem þú ættir að taka eftir er að byrjun fallaskilgreiningarinnar er öðruvísi.
Í stað {\tt void}, sem gefur til kynna void fall, þá sjáum við hér {\tt double} sem gefur til kynna að skilagildið úr þessu falli sé af taginu {\tt double}.

Taktu líka eftir að síðasta línan í fallinu er önnur útgáfa af {\tt return} setningu sem inniheldur skilagildi.
Þessi setning þýðir ``hætta strax keyrslu þessa falls og nota eftirfarandi segð sem skilagildið.''
Segðin. sem kemur á eftir lykilorðinu return. getur verið eins flókin og verða vill þannig að við gætum hafa skrifað fallið á samþjappaðri hátt:

\begin{verbatim}
double area (double radius) {
  return acos(-1.0) * radius * radius;
}
\end{verbatim}
%
Á hinn bóginn má segja að, {\bf tímabundnar} (e. temporary) breytur eins og {\tt area} gera kembingu oft auðveldari.
Í báðum tilvikum þarf tag segðarinnar í return setningunni að passa við skilatag fallsins.
M.ö.o., þegar þú skilgreinir að skilagildið sé af taginu {\tt double} þá ert ``lofar'' þú því að fallið muni að endingu skila {\tt double}.
Þýðandinn mun kvarta ef þú reynir að skila engri segð eða segð af röngu tagi. 

\index{tímabundin breyta}
\index{breyta!tímabundin}

Stundum getur verið hentug að hafa margar return setningar í falli -- eina fyrir sérhverja kvísl í skilyrðissetningu:Sometimes it is useful to have multiple return

\begin{verbatim}
double absoluteValue (double x) {
  if (x < 0) {
    return -x;
  } else {
    return x;
  }
}
\end{verbatim}
%
Aðeins ein af þessum return setningum mun verða keyrð þar sem return setningarnar eru í mismunandi kvíslum.
Þrátt fyrir að það sé leyfilegt að hafa fleiri en eina {\tt return} setningu í falli þá skaltu muna að um leið og ein þeirra er keyrð þá hættir fallið keyrslu og mun ekki keyra þær setningar sem á eftir koma.

Kóði sem kemur á eftir {\tt return} setningu, eða á stað sem flæðið mun ekki komast í, er kallaður {\bf dauður kóði} (e. dead code).
Sumir þýðendur gefa einmitt aðvaranir ef hluti kóða er ``dauður''.

\index{dauður kóði}

Ef þú setur return setningu innan í skilyrðissetningu þá þarftu að sjá til þess að {\em sérhver möguleg leið} gegnum forritið lendi að lokum á return setningu.
Dæmi: 

\begin{verbatim}
double absoluteValue (double x) {
  if (x < 0) {
    return -x;
  } else if (x > 0) {
    return x;
  }                          // WRONG!!
}
\end{verbatim}
%
Þetta forrit er ekki rétt vegna þess að ef {\tt x} er 0 þá er hvorugt skilyrðanna satt og fallið mun þá hætta keyrslu án þess að framkvæma return setningu. then
Því miður þá grípa ekki allir C++ þýðendur þessa villu.
Því má vera að forritið þýðist og keyrist en þegar {\tt x==0} þá getur skilagildið í raun verið hvað sem er og líklega mismunandi eftir ólíkum umhverfum.

\index{tölugildi}
\index{villa!á þýðandatíma}
%\index{compile-time error}

Núna ert þú líklega orðin(n) hundleið(ur) á þýðandavillum en eftir því sem reynslan eykst þá áttar þú þig á því 
að það eina sem er verra en að fá þýðandavillu er að fá {\em ekki} þýðandavillu þegar forritið er ekki rétt!

Hér er dæmi um eitthvað sem gæti gerst: Þú prófar {\tt absoluteValue} með ýmsum mismunandi gildum á {\tt x} og það virðist virka rétt.
Þú lætur síðan einhvern annan fá forritið og viðkomandi prófar það í öðru umhverfi.
Á einhvern dularfullan hátt skilar það ekki réttu gildi og eftir nokkra daga kembingu kemstu að því að útfærslan á {\tt absoluteValue} er ekki rétt.
Bara ef þýðandinn hefði aðvarað þig!

%\index{compile-time error}
%\index{error!compile-time}
\index{aflúsun}
\index{kembing}

Framvegis skaltu ekki álasa þýðandanum ef hann bendir á villu í forritinu þínu.
Þú skalt frekar þakka honum fyrir a finna villu og spara þér nokkrar daga vinnu við aflúsun.
Sumum þýðendur hafa valkost sem segir þeiim að vera sérstaklega ``strangur'' og greina frá öllum villum sem þeir finna.
Þú ættir alltaf að velja þennan valkost í þínum þýðanda.

\index{stærðfræðifall!fabs}

Sem innskot þá bendi ég á að það er fall í math safninu sem heitir {\tt fabs}.
Það reiknar tölugildið á {\tt double} -- á réttan hátt.

\section{Þróun forrits}
\label{distance}
\index{þróun forrits}

Á þessum tímapunkti ættir þú að geta skoðað C++ föll í heild sinni og sagt til um hvað þau gera.
Aftur á móti er þér kannski ekki ljóst hvernig eigi að skrifa þau.
Ég mun núna stinga upp á einni aðferð við þróun forrits sem ég kalla {\bf stigvaxandi þróun} (e. incremental development).

\index{stigvaxandi þróun}
\index{þróun forrits}

Gefum okkur t.d. að þú þurfir að skrifa fall sem reiknar fjarlægðina á milli tveggja punkta sem gefnir eru með hitunum $(x_1, y_1)$ og $(x_2, y_2)$.
Hefðbundna skilgreiningin á fjarlægð tveggja punkta er:

\begin{equation}
distance = \sqrt{(x_2 - x_1)^2 + (y_2 - y_1)^2}
\end{equation}
%
Fyrsta skrefið er að íhuga hvernig {\tt distance} fall ætti að líta út í C++.
M.ö.o., hvert er inntakið (leppar/viðföng) og hvert er úttakið (return gildið).

Í þessu tilvik eru punktarnir tveir auðvitað viðföngin inn í fallið og það er eðlilegt að nota fjóra leppa af taginu {\tt double}.
Skilagildið er fjarlægð sem er líka eðlilegt að beri tagið {\tt double}.

Nú þegar getum við því skrifað drög að fallinu:

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  return 0.0;
}
\end{verbatim}
%
{\tt Return} setningin er þarna að forminu til svo að fallið þýðist og keyri þrátt fyrir að setningin skili ekki réttu gildi.
Á þessu stigi gerir fallið í raun ekkert gagnlegt en það er þess virði að reyna að þýða það strax svo við getum fundið málskipunarvillur áður en fallið verður flóknara.

Til að prófa nýja fallið verðum við að kalla á það með einhverjum tilraunagildum (viðföngum).
Einhversstaðar í {\tt main} myndi ég bæta við:

\begin{verbatim}
  double dist = distance (1.0, 2.0, 4.0, 6.0);
  cout << dist << endl;
\end{verbatim}
%
Ég valdi gildin þannig að lárétta fjarlægðin er 3 og lóðrétta fjarlægðin er 4.
Þá ætti niðurstaðan að vera 5 (langhliðin í 3-4-5 þríhyrningi).
Það er gagnlegt að vita rétta svarið þegar maður prófar fall!

Þegar við höfum athugað að málskipanin í fallaskilgreiningunni okkar er rétt getum við byrjað á því að bæta við setningum í fallið, einni í einu.
Svo þýðum við og keyrum forritið eftir sérhverja (stigvaxandi) breytingu.
Ef villa kemur upp þá vitum við nákvæmlega hvar hún er -- í síðustu línunni sem við bættum við.

Næsta skref í útreikningnum okkar er að finna mismuninn á $x_2 - x_1$ og $y_2 - y_1$.
Ég mun geyma þessi gildi (milliniðurstöður) í tímabundnum breytum sem ég nefni {\tt dx} og {\tt dy}.

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  double dx = x2 - x1;
  double dy = y2 - y1;
  cout << "dx is " << dx << endl;
  cout << "dy is " << dy << endl;
  return 0.0;
}
\end{verbatim}
%
Ég bætti við úttakssetningum sem skrifa út gildin á tímabundnu breytunum. 
Eins og ég nefndi að ofan þá veit ég þegar að þessi gildi ættu að vera 3,0 og 4,0.

\index{stoðbúnaður}

Ég mun síðan fjarlægja þessar úttakssetningar þegar ég hef lokið við þróun fallsins.
Kóði eins og þessi er einsskonar {\bf stoðbúnaður} (e. scaffolding) vegna þess að hann hjálpar til við þróun fallsins en er ekki hluti af endanlegri útgáfu þess.

Stundum er reyndar gott að fjarlægja ekki stoðbúnaðinn algerlega heldur setja hann inn í athugasemdir (e. comments) ef ske kynni að við þyrftum á honum að halda síðar.

Næsta skref í þróun fallsins er þá að setja {\tt dx} og {\tt dy} í annað veldi og leggja niðurstöðurnar saman.
Við gætum notað {\tt pow} fallið en það er einfaldara og fljótvirkara að margfalda hvorn liðinn með sjálfu sér.

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  double dx = x2 - x1;
  double dy = y2 - y1;
  double dsquared = dx*dx + dy*dy;
  cout << "dsquared is " << dsquared;
  return 0.0;
}
\end{verbatim}
%
Hér myndi ég aftur þýða og keyra forritið og athuga milliniðurstöðuna (tímabundna gildið) sem ætti að vera 25,0.

Að lokum notum við {\tt sqrt} fallið til að reikna og skila lokaniðurstöðunni.

\begin{verbatim}
double distance (double x1, double y1, double x2, double y2) {
  double dx = x2 - x1;
  double dy = y2 - y1;
  double dsquared = dx*dx + dy*dy;
  double result = sqrt (dsquared);
  return result;
}
\end{verbatim}
%
Í {\tt main} ættum við síðan að skrifa út og athuga gildið sem við fáum til baka úr kallinu á fallið distance.

Eftir því sem reynslan þín eykst þá muntu skrifa og kemba fleiri en eina línu í einu.
Samt sem áður mun þetta stigvaxandi þróunarferli spara þér mikinn tíma við kembingu síðar meir.

Megin þættir í þessu ferli eru:

\begin{itemize}

\item Byrjaðu með forrit sem keyrir og gerðu litlar, stigvaxtandi breytingar.
Ef einhver villa kemur upp þá veistu nákvæmlega hvar hún er.

\item Notaðu tímabundnar breytur til að geyma milliniðurstöður þannig að þú getir skrifað þær út.

\item Þegar forritið er tilbúið þá viltu kannski fjarlægja stoðbúnaðinn eða skipta mörgum setningum út fyrir samsettar segðir (e. compound expressions), en þó aðeins ef það gerir forritið þitt ekki ólæsilegra.

\end{itemize}

\section{Samsetning}
\index{samsetning}

Þegar þú hefur skilgreint nýtt fall þá getur þú notað það sem hluta af segð og þú getur einnig skilgreint ný föll með því að nota þau föll sem eru þegar til.
Hvað ef t.d. einhver gæfi þér tvo punkta, miðju hrings og punkt á hringnum, og spyrði um flatarmál hringsins?

Gefum okkur að miðjan sé geymd í breytunum {\tt xc} og {\tt yc} og punkturinn á hringnum í {\tt xp} og {\tt yp}.
Fyrsta skrefið er þá að finna radíus hringsins, þ.e. fjarlægðina á milli punktanna tveggja.
Við eigum einmitt fall, {\tt distance}, sem gerir það!

\begin{verbatim}
  double radius = distance (xc, yc, xp, yp);
\end{verbatim}
%
Næsta skref er síðan að finna flatarmál hrings með þennan radíus og skila því.

\begin{verbatim}
  double result = area (radius);
  return result;
\end{verbatim}
%
Ef við setjum þennan kóða inn í sér fall þá fáum við:

\begin{verbatim}
double fred (double xc, double yc, double xp, double yp) {
  double radius = distance (xc, yc, xp, yp);
  double result = area (radius);
  return result;
} 
\end{verbatim}
%
Nafnið á þessu falli er {\tt fred} sem er vissulega skrýtið.
Í næsta kafla mun ég skýra út af hverju nanfið er undarlegt.

Tímabundnu breyturnar {\tt radius} og {\tt area} eru gagnlegar í þróuninni og í kembun 
en þegar við erum viss um að fallið virki þá getum skrifað það á samþjappaðra hátt með því að setja saman fallaköllin tvö:

\begin{verbatim}
double fred (double xc, double yc, double xp, double yp) {
  return area (distance (xc, yc, xp, yp));
} 
\end{verbatim}

\section{Fjölbinding}
\label{overloading}
\index{fjölbinding}

Þú hefur kannski tekið eftir því, í kaflanum hér á undan, að föllin
{\tt fred} og {\tt area} hafa sama hlutverk -- finna flatarmál hrings -- en taka samt mismunandi viðföng. 
Við sendum radíus sem viðfang í {\tt area} en tvo punkta sem viðfögn í {\tt fred}.

Ef tvö föll framkvæma sömu aðgerð þá er eðlilegt að gefa þeim sama nafn.
M.ö.o, það væri eðlilegra ef fallið {\tt fred} væri kallað {\tt area}.

Það er leyfilegt í C++ að hafa fleiri en eitt fall með sama nafninu svo framarlega sem sérhver útgáfa taki mismunandi viðföng.
Þessi eiginleiki er kallaður {\bf fjölbinding} (e. overloading).
Við getum því endurskýrt {\tt fred}:

\begin{verbatim}
double area (double xc, double yc, double xp, double yp) {
  return area (distance (xc, yc, xp, yp));
} 
\end{verbatim}
%
Nú lítur þetta út eins og endurkvæmt fall en svo er ekki.
Það vill svo til að þessi útgáfa af {\tt area} kallar á hina útgáfuna!
Þegar þú kallar á fjölbundið fall þá veit C++ þýðandinn hvaða útgáfu verið er að kalla á með því að skoða viðföngin sem notuð eru.
Ef þú skrifar

\begin{verbatim}
    double x = area (3.0);
\end{verbatim}
%
þá mun C++ þýðandinn leita að fall með nafninu {\tt area} sem tekur {\tt double} sem viðfang og notar því fyrri úgáfuna.
Ef þú skrifar

\begin{verbatim}
    double x = area (1.0, 2.0, 4.0, 6.0);
\end{verbatim}
%
þá notar þýðandinn seinni útgáfuna af {\tt area}.  

Margar af innbyggðu C++ aðgerðunum eru fjölbundnar sem þýðir að það eru til mismunandir útgáfur sem taka mismunandi fjölda af viðföngunum eða mismunandi að tag viðfanganna er mismunandi.

Fjölbinding er gagnlegur eiginleiki en skal samt sem áður nota með varúð.
Það getur verið ruglandi ef þú kembir eina útgáfu af falli sem síðan kallar á aðra útgáfu þess.

Þetta minnir mig reyndar á eina grundvallarreglu varðandi kembingu:
{\bf vertu viss um að útgáfan af forritun sem þú ert að skoða sé útgáfan sem er í raun keyrandi!}
Stundum lendur þú í því að gera breytingu eftir breytingu á forritinu þínu en samt sem áður sérðu alltaf sama úttak þegar þú keyrir það.
Þetta er merki um það að af einhverjum ástæðum þá ertu ekki að keyra þá útgáfu af forritun sem þú heldur að þú sért að keyra.
Til að vera viss þá getur þú skotið inn úttakssetningu (það skiptir í raun ekki máli hvað þú skrifar út) og þannig gengið úr skugga um að rétta útgáfan af forritinu sé keyrandi.

\section{Boole gildi}
\index{boolean}
\index{gildi!boole}

Tögin sem við höfum hingað til séð eru frekar stór.
Það eru ansi margar heiltölur til í heiminum og enn fleiri kommutölur.
Í samanburði er mengi stafa hins vegar frekar smátt.
Það er reyndar eitt C++ tag sem er enn smærra.
Það er kallað {\bf boole} og einu leyfilegu gildi þess eru gildin {\tt true} og {\tt false}.

Í síðustu tveimur köflum höfum við notað boole gildi án þess að fjalla sérstaklega um það.
Skilyrðið innan í {\tt if} setningu er einmitt boole segð og niðurstaðan af beitingu samanburðarvirkja er boole gildi.
Dæmi:

\begin{verbatim}
  if (x == 5) {
    // do something
  }
\end{verbatim}
%
Samanburðarvirkinn {\tt ==} ber hér saman tvö heiltölugildi og skilar boole gildi.

\index{virki!samanburður}
\index{samanburðarvirki}

Gildin {\tt true} og {\tt false} eru lykilorð í C++ 
og geta verið notuð hvar sem gert er ráð fyrir boole segð.
Dæmi:  

\begin{verbatim}
  while (true) {
    // loop forever
  }
\end{verbatim}
%
Þetta er staðlað sniðmát fyrir lykkju sem ætti að keyra endalaust (eða þangað til að komið er að {\tt return} eða {\tt break} setningu).

\section{Boole breytur}
\index{tag!{\tt bool}}

Fyrir sérhvert tag á gildi er samsvarandi tag á breytu.
Í C++ er boole tagið kallað {\bf bool}.
Breytur af taginu bool eru skilgreindar á sama hátt og breytur sem af öðru tagi:

\begin{verbatim}
  bool fred;
  fred = true;
  bool testResult = false;
\end{verbatim}
%
Fyrsta línan er einföld yfirlýsing á breytu.
Önnur línan er gildisveiting og þriðja línan er samsetning á yfirlýsingu og gildisveitingu, þ.e. upphafsstilling.

\index{upphafsstilling}
\index{setning!upphafsstilling}

Eins og ég nefndi að ofan þá er niðurstaðan úr samanburði alltaf booole gildi þannig að hægt er að geyma hana í {\tt bool} breytu

\begin{verbatim}
  bool evenFlag = (n%2 == 0);     // true if n is even
  bool positiveFlag = (x > 0);    // true if x is positive
\end{verbatim}
%
og nota breytuna síðar í skilyrðissetningu 

\begin{verbatim}
  if (evenFlag) {
    cout << "n was even when I checked it" << endl;
  }
\end{verbatim}
%
Breyta sem notuð er á þennan hátt er oft kölluð {\bf flagg} (e. flag),
vegna þess að hún gefur til kynna (``flaggar'') að eitthvað skilyrði sé til staðar eður ei.

\index{flagg}

\section{Rökvirkjar}
\index{rökvirki}
\index{virki!rök}

Í C++ eru þrír {\bf rökvirkjar} (e. logical operators): AND, OR og NOT,
sem eru táknaðir með {\tt \&\&}, {\tt ||} og {\tt !}.
Merking þessar virkja er svipuð og merking þeirra í náttúrulegu máli (ensku).
T.d. er {\tt x > 0 \&\& x < 10} true (satt) aðeins ef {\tt x} er stærra en 0 OG (AND) minna en 10.

\index{merking}

{\tt evenFlag || n\%3 == 0} er true ef {\em annað} skilyrðanna er true, þ.e. ef {\tt evenFlag} er true EÐA (OR) að talan er deilanleg með 3.

Að lokum hefur NOT virkinn þau áhrif að neita eða snúa við gildi boole segðar.
Þannig er {\tt !evenFlag} true ef {\tt evenFlag} er false,  þ.e. ef talan er oddatala.

\index{hreiðruð skilyrði}

Rökvirkjar gefa oft möguleika á því að einfalda hreiðraðar skilyrðissetningar.
Hvernig myndir þú t.d. skrifa eftirfarandi kóða með því að nota eitt skilyrði sem samsett er úr rökvirkjum?

\begin{verbatim}
  if (x > 0) {
    if (x < 10) {
      cout << "x is a positive single digit." << endl;
    }
  }
\end{verbatim}

\section{Boole föll}
\label{bool}
\index{boole}
\index{fall!boole}

Föll geta skilað {\tt bool} gildum eins og hvaða öðru gildi.
Það er oft hentugt þegar hylja þarf flókið skilyrði innan í falli:
Dæmi:

\begin{verbatim}
bool isSingleDigit (int x)
{
  if (x >= 0 && x < 10) {
    return true;
  } else {
    return false;
  }
}
\end{verbatim}
%
Nafnið á þessu falli er {\tt isSingleDigit}.
Algengt er að gefa boole föllum nöfn sem hljóma eins og já/nei spurningar.
Skilagildið er {\tt bool} sem þýðir að sérhver return setningar þarf að hafa segð af taginu {\tt bool} í för með sér.

Kóðinn sjálfur er einfaldur þrátt fyrir að vera aðeins lengri en nauðsynlegt er.
Mundu að segðin {\tt x >= 0 \&\& x < 10} hefur tagið {\tt bool} þannig að það er ekkert athugavert við það að skila henni beint og þar með sleppa {\tt if} setningunni:

\begin{verbatim}
bool isSingleDigit (int x)
{
  return (x >= 0 && x < 10);
}
\end{verbatim}
%
Í {\tt main} getur þú kallað á þetta fall á venjulegan hátt:

\begin{verbatim}
  cout << isSingleDigit (2) << endl;
  bool bigFlag = !isSingleDigit (17);
\end{verbatim}
%
Fyrsta línan skrifar út gildið {\tt true} vegna þess að talan 2 samanstendur af einum tölustaf.
Það vill reyndar svo til að þegar C++ skrifar út {\tt bool} gildi þá eru orðin {\tt true} og {\tt false} ekki skrifuð út 
heldur frekar heiltölurnar {\tt 1} og {\tt 0}.
%\footnote{There is a way to fix that using the {\tt boolalpha} flag, but it is too hideous to mention.}

Í annarri línunni fær breytan {\tt bigFlag} gildið {\tt true} vegna þess að talan 17 er {\em ekki} (not) tala með einum tölustaf.

Algengasta notkun á {\tt bool} föllum er innan í skilyrðissetningu: 

\begin{verbatim}
  if (isSingleDigit (x)) {
    cout << "x is little" << endl;
  } else {
    cout << "x is big" << endl;
  }
\end{verbatim}

\section {Returning from {\tt main}}

Now that we have functions that return values, I can let you in
on a secret.  {\tt main} is not really supposed to be a {\tt void}
function.  It's supposed to return an integer:

\begin{verbatim}
int main ()
{
  return 0;
}  
\end{verbatim}
%
The usual return value from {\tt main} is 0, which indicates that
the program succeeded at whatever it was supposed to to.  If something
goes wrong, it is common to return -1, or some other value that
indicates what kind of error occurred.

Of course, you might wonder who this value gets returned to, since
we never call {\tt main} ourselves.  It turns out that when the
system executes a program, it starts by calling {\tt main}
in pretty much the same way it calls all the other functions.

There are even some parameters that are passed to {\tt main}
by the system, but we are not going to deal with them for a little
while.

\section {More recursion}
\index{recursion}
\index{language!complete}

So far we have only learned a small subset of C++, but you
might be interested to know that this subset is now
a {\bf complete} programming language, by which I
mean that anything that can be computed can be expressed in this
language.  Any program ever written could be rewritten
using only the language features we have used so far (actually, we
would need a few commands to control devices like the keyboard, mouse,
disks, etc., but that's all).

\index{Turing, Alan}

Proving that claim is a non-trivial exercise first
accomplished by Alan Turing, one of the first computer scientists
(well, some would argue that he was a mathematician, but a lot of the
early computer scientists started as mathematicians).  Accordingly, it
is known as the Turing thesis.  If you take a course on the Theory of
Computation, you will have a chance to see the proof.

To give you an idea of what you can do with the tools we have learned
so far, we'll evaluate a few recursively-defined
mathematical functions.  A recursive definition is similar to a
circular definition, in the sense that the definition contains a
reference to the thing being defined.  A truly circular definition is
typically not very useful:

\begin{description}

\item[frabjuous:] an adjective used to describe
something that is frabjuous.

\index{frabjuous}

\end{description}

If you saw that definition in the dictionary, you might be
annoyed.  On the other hand, if you looked up the definition
of the mathematical function {\bf factorial}, you might
get something like:

\begin{eqnarray*}
&&  0! = 1 \\
&&  n! = n \cdot (n-1)!
\end{eqnarray*}

(Factorial is usually denoted with the symbol $!$, which is
not to be confused with the C++ logical operator {\tt !} which
means NOT.)  This definition says that the factorial of 0 is 1,
and the factorial of any other value, $n$, is $n$ multiplied
by the factorial of $n-1$.  So $3!$ is 3 times $2!$, which is 2 times
$1!$, which is 1 times 0!.  Putting it all together, we get
$3!$ equal to 3 times 2 times 1 times 1, which is 6.

If you can write a recursive definition of something, you can usually
write a C++ program to evaluate it.  The first step is to decide what
the parameters are for this function, and what the return type is.
With a little thought, you should conclude that factorial takes an
integer as a parameter and returns an integer:

\begin{verbatim}
int factorial (int n)
{
}
\end{verbatim}
%
If the argument happens to be zero, all we have to do is
return 1:

\begin{verbatim}
int factorial (int n)
{
  if (n == 0) {
    return 1;
  }
}
\end{verbatim}
%
Otherwise, and this is the interesting part, we have to make
a recursive call to find the factorial of $n-1$, and then
multiply it by $n$.

\begin{verbatim}
int factorial (int n)
{
  if (n == 0) {
    return 1;
  } else {
    int recurse = factorial (n-1);
    int result = n * recurse;
    return result;
  }
}
\end{verbatim}
%
If we look at the flow of execution for this program,
it is similar to {\tt nLines} from the previous chapter.
If we call {\tt factorial} with the value 3:

Since 3 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 2 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 1 is not zero, we take the second branch and calculate
the factorial of $n-1$...

\begin{quote}
Since 0 {\em is} zero, we take the first branch and return
the value 1 immediately without making any more recursive
calls.

\end{quote}

The return value (1) gets multiplied by {\tt n}, which is 1,
and the result is returned.

\end{quote}

The return value (1) gets multiplied by {\tt n}, which is 2,
and the result is returned.

\end{quote}

\noindent The return value (2) gets multiplied by {\tt n}, which is 3,
and the result, 6, is returned to {\tt main}, or whoever
called {\tt factorial (3)}.

\index{stack}
\index{diagram!state}
\index{diagram!stack}

Here is what the stack diagram looks like for this sequence of
function calls:

\vspace{0.1in}
\centerline{\epsfig{figure=stack3.eps}}
\vspace{0.1in}
%
The return values are shown being passed back up the stack.

Notice that in the last instance of {\tt factorial}, the local
variables {\tt recurse} and {\tt result} do not exist because
when {\tt n=0} the branch that creates them does not execute.

\section{Leap of faith}
\index{leap of faith}

Following the flow of execution is one way to read programs, but as
you saw in the previous section, it can quickly become labarynthine.
An alternative is what I call the ``leap of faith.''  When you come to
a function call, instead of following the flow of execution, you
{\em assume} that the function works correctly and returns the
appropriate value.

In fact, you are already practicing this leap of faith
when you use built-in functions.  When you call {\tt cos}
or {\tt exp}, you don't examine the implementations of 
those functions.  You just assume that they work, because the people
who wrote the built-in libraries were good programmers.

Well, the same is true when you call one of your own functions.
For example, in Section~\ref{bool} we wrote a function called
{\tt isSingleDigit} that determines whether a number is between
0 and 9.  Once we have convinced ourselves that this function
is correct---by testing and examination of the code---we can
use the function without ever looking at the code again.

The same is true of recursive programs.  When you get to the recursive
call, instead of following the flow of execution, you should {\em
assume} that the recursive call works (yields the correct result), and
then ask yourself, ``Assuming that I can find the factorial of $n-1$,
can I compute the factorial of $n$?''  In this case, it is clear that
you can, by multiplying by $n$.

Of course, it is a bit strange to assume that the function works
correctly when you have not even finished writing it, but that's why
it's called a leap of faith!

\section{One more example}
\index{factorial}

In the previous example I used temporary variables to spell out the
steps, and to make the code easier to debug, but I could have saved a
few lines:

\begin{verbatim}
int factorial (int n) {
  if (n == 0) {
    return 1;
  } else {
    return n * factorial (n-1);
  }
}
\end{verbatim}
%
From now on I will tend to use the more concise version, but
I recommend that you use the more explicit version while you
are developing code.   When you have it working, you can
tighten it up, if you are feeling inspired.

After {\tt factorial}, the classic example of a recursively-defined
mathematical function is {\tt fibonacci}, which has the
following definition:

\begin{eqnarray*}
&& fibonacci(0) = 1 \\
&& fibonacci(1) = 1 \\
&& fibonacci(n) = fibonacci(n-1) + fibonacci(n-2);
\end{eqnarray*}
%
Translated into C++, this is

\begin{verbatim}
int fibonacci (int n) {
  if (n == 0 || n == 1) {
    return 1;
  } else {
    return fibonacci (n-1) + fibonacci (n-2);
  }
}
\end{verbatim}
%
If you try to follow the flow of execution here, even for fairly small
values of {\tt n}, your head explodes.  But according to the leap of
faith, if we assume that the two recursive calls (yes, you can make
two recursive calls) work correctly, then it is clear that we get the
right result by adding them together.

\section{Glossary}

\begin{description}

\item[return type:]  The type of value a function returns.

\item[return value:]  The value provided as the result of a function
call.

\item[dead code:]  Part of a program that can never be executed,
often because it appears after a {\tt return} statement.

\item[scaffolding:]  Code that is used during program development
but is not part of the final version.

\item[void:]  A special return type that indicates a void function;
that is, one that does not return a value.

\item[overloading:]  Having more than one function with the same name
but different parameters.  When you call an overloaded function,
C++ knows which version to use by looking at the arguments you
provide.

\item[boolean:]  A value or variable that can take on one of
two states, often called $true$ and $false$.  In C++, boolean
values can be stored in a variable type called {\tt bool}.

\item[flag:]  A variable (usually type {\tt bool}) that records
a condition or status information.

\item[comparison operator:]  An operator that compares two values
and produces a boolean that indicates the relationship between the
operands.

\item[logical operator:]  An operator that combines boolean values
in order to test compound conditions.

\index{return type}
\index{return value}
\index{dead code}
\index{scaffolding}
\index{void}
\index{overloading}
\index{bool}
\index{operator!conditional}
\index{operator!logical}

\end{description}

