% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

% This is an Icelandic translation/adaptation of the orginal book by Allen B. Downey


\chapter{Breytur og tög}

\section{Meira úttak}
\index{úttak}
\index{setning!úttak}

Eins og bent var á í síðasta kafla þá getur þú haft eins margar setningar og þú vilt í {\tt main}.
T.d., til að skrifa út fleiri en eina línu: 

\begin{verbatim}
#include <iostream>
using namespace std;
// main: generate some simple output

int main ()
{
  cout << "Hello, world." << endl;     // output one line
  cout << "How are you?" << endl;      // output another
  return 0;
}
\end{verbatim}
%
Eins og hér sést þá er löglegt að setja inn athugasemdir í enda línu sem og í sér línu.

\index{String}
\index{type!String}

Þeir hlutar setninganna að ofan sem birtir eru innan gæsalappa eru kallaðir {\bf strengir} (e. strings),
vegna þess að þeir samanstanda af röð (streng) af bókstöfum.
Reyndar vill svo til að strengir get innhaldið hvað samsetningu sem er af bókstöfum, tölum, greinarmerkjum og öðrum sérstökum táknum.
because they are made up of a sequence (string) of letters.  Actually,

%\index{newline}
\index{lína!ný}

Oft er gagnlegt að sýna úttak úr mörgum úttakssetningum í einni og sömu línunni.
Þetta er hægt að gera með því að sleppa fyrsta {\tt endl}:

\begin{verbatim}
int main ()
{
  cout << "Goodbye, ";
  cout << "cruel world!" << endl;
  return 0
}
\end{verbatim}
%
Í þessu tilviki birtist úttakið í einni línu sem {\tt Goodbye, cruel world!}.
Athugið að í forritinu er eitt bil (e. space) á milli stafarununnar ``Goodbye,'' og seinni gæsalapparinnar.
Þetta bil birtist í úttaki forritsins og bilið í forritinu sjálfu hefur því áhrif á virkni þess.

Bil sem koma fyrir utan gæsalappa í forriti hafa aftur á móti ekki áhrif á virkni forritsins.
Ég gæti t.d. hafa skrifað:

\begin{verbatim}
int main ()
{
  cout<<"Goodbye, ";
  cout<<"cruel world!"<<endl;
  return 0;
}
\end{verbatim}
%
Þetta forrit þýðist og keyrist á sama hátt og upphaflega forritið.
Skil (e. break) í enda línu (e. newline) hafa heldur ekki áhrif á virkni forritsins.
Ég gæti því einnig hafa skrifað:

\begin{verbatim}
int main(){cout<<"Goodbye, ";cout<<"cruel world!"<<endl;return 0;}
\end{verbatim}
%
Þetta myndi líka virka en eins og þú hefur væntanlega tekið eftir þá hafa þessar breytingar gert það að verkum að forrritið hefur orðið ólæsilegra.
Skil á milli lína og bil eru einmitt gagnleg fyrir okkur því lestur forritsins verður auðveldari og gerir okkur jafnframt auðveldara um vik við að finna málskipunarvillur.

\section{Gildi}
\index{gildi}
\index{tag}

{\bf Gildi} (e. value) (t.d. bókstafur eða tala) er eitt af þeim megin atriðum sem forrit vinnur með.
Einu gildin sem við höfum unnið með hingað til eru strengjagildi, eins og {\tt "Hello, world."}.
Þú (og þýðandinn) getur borið kennsl á strengjagildi vegna þess að strengir eru runa af stöfum innan gæsalappa.

Önnur dæmi um gildi eru heiltölur (e. integers) og stafir (e. characters).
Dæmi um heiltölu er {\tt 1} eða {\tt 17}. 
Þú getur skrifað út heiltölugildi á sama hátt og þú skrifar út gildi á strengjum:

\begin{verbatim}
  cout << 17 << endl;
\end{verbatim}
%
Stafagildi er bókstafur, tölustafur eða greinarmerki innan einfaldra gæsalappa, t.d. {\tt 'a'} eða {\tt '5'}.
Þú getur skrifað út stafagildi á sama hátt:

\begin{verbatim}
  cout << '}' << endl;
\end{verbatim}
%
Í þessu dæmi er slaufusvigi skrifaður út einn og sér í línu.

Það er einfalt á ruglast á hinum ýmsu tegundum af gildum eins og 
{\tt "5"}, {\tt '5'} og {\tt 5}, en ef þú skoðar greinarmerkin þá ætti að vera ljóst að
fyrsta gildið er strengur, annað gildi er stafur og þriðja gildið er heiltala.
Ástæðan fyrir mikilvægi þessarar aðgreiningar mun bráðum verða ljós.

\section {Breytur}
\index{breyta}
\index{gildi}

Einn öflugasti eiginleiki forritunarmáls er að sá að gera forritara kleift að vinna með {\bf breytur} (e. variables).
Breyta er nafn sem stendur fyrir minnissvæði sem geymir gildi. 

Ýmsar mismunandi tegundir af breytum eru til (á sama hátt og mismunandi tegundir af gildum).
Þegar þú býrð til nýja breytu þá þarftu (í C++) að skilgreina af hvaða {\bf tagi} (e. type) breytan er.
Í C++ er stafur t.d. kallaður (skilgreindur sem) {\tt char}.
Eftirfarandi setning býr til nýja breytu með nafninu {\tt fred} sem hefur tagið {\tt char}.

\begin{verbatim}
    char fred;
\end{verbatim}
%
Ofangreind setning er kölluð {\bf yfirlýsing} (e. declaration) (því setningin lýsir yfir breytu með tilteknu tagi).

Tag breytu ákvarðar hvers konar gildi hún getur geymt.
Breyta af taginu {\tt char} getur geymt stafi og það ætti ekki að koma á óvart að {\tt int} breyta geti geymt heiltölur.

Í C++ eru nokkur tög sem geta geymt strengjagildi en við skoðum það seinna í kafla~\ref{strings}.

\index{yfirlýsing}
\index{setning!yfirlýsing}

Málskipanin sem notuð er til að lýsa yfir heiltölubreytu er: 

\begin{verbatim}
  int bob;
\end{verbatim}
%
Hér er {\tt bob} eitthvað handahófskennt nafn á heiltölubreytunni.
Almennt séð er góð regla að gefa breytum nöfn sem gefa til kynna fyrir hvað þær standa.
Ef þú sæir t.d. eftirfarandi yfirlýsingar: 

\begin{verbatim}
    char firstLetter;
    char lastLetter;
    int hour, minute;
\end{verbatim}
%
þá gætir þú væntanlega getið þér til um hvað gildi stendur til að geyma í þessum breytum.
Þetta dæmi sýnir líka málskipanina sem notuð er til þess að lýsa yfir mörgum breytum með sama tagið: {\tt hour} og {\tt minute}
eru bæði heiltölur með tagið {\tt int}.

\section{Gildisveiting}
\index{gildisveiting}
\index{setning!gildisveiting}

Þegar við höfum lýst yfir (búið til) breytum þá myndum við gjarnan vilja geyma einhver gildi í þeim.
Það gerum við með svokölluðum {\bf gildisveitingum} (e. assignments):

\begin{verbatim}
    firstLetter = 'a';   // give firstLetter the value 'a'
    hour = 11;           // assign the value 11 to hour
    minute = 59;         // set minute to 59
\end{verbatim}
%
Þetta dæmi sýnir þrjár gildisveitingar og athugasemdirnar sýna hvernig hægt er að tala um gildisveitingarsetningar á mismunandi hátt.
Það má vera að orðaforðinn sé ruglingslegur en hugmyndin er einföld: 

\begin{itemize}
\item Þegar þú lýsir yfir breytu þá býrð þú til minnissvæði sem geymir gildi breytunnar.
\item Í gildisveitingarsetningu er breytu gefið gildi. 
\end{itemize}

Algeng leið til að tákna breytu á pappír er að teikna kassa
með nafni breytunnar fyrir utan kassann og gildi breytunnar inna í kassanum.
Þessi tegund af mynd er kölluð {\bf stöðurit} (e. state diagram) vegna þess að hún sýnir hver staða sérhverrar breytu er (hægt er að hugsa sér að breyta hafi ``state of mind'').
because is shows what state each of the
Eftirfarandi mynd sýnir hvaða áhrif gildisveitingarsetningarnar þrjár hafa: 

\vspace{0.1in}
\centerline{\epsfig{figure=assign.eps}}
\vspace{0.1in}

Ég nota stundum mismunandi form til að gefa til kynna mismunandi tög breytna.
Þessi form ættu að minna þig á að ein C++ reglan krefst þess að breyta hafa sama tag og gildið sem þú gefur henni.
Þú getur t.d. ekki geymt streng í {\tt int} breytu.
C++ þýðandi samþykkir t.d. ekki eftirfarandi setningu: 

\begin{verbatim}
  int hour;
  hour = "Hello.";       // WRONG !!
\end{verbatim}
%
Þessi regla veldur stundum ruglingi því þar eru margar leiðir til að breyta gildi af einu tagi í annað og C++ breytir meira að segja tagi stundum sjálkrafa.
Sem stendur skaltu muna að almenna reglan er sú að breytur og gildi þurfa að vera af sama tagi en við munum tala um sérstök tilfelli síðar.

Annað sem getur valdið misskilningi er að sumir strengir {\em líta út} eins og heiltölur en eru það ekki.
Strengurinn {\tt "123"}, sem samanstendur af stöfunum {\tt 1}, {\tt 2} og {\tt 3}, er t.d. ekki sami hluturinn og {\em talan} {\tt 123}.
Eftirfarandi gildisveiting er ólögleg:

\begin{verbatim}
  minute = "59";         // WRONG!
\end{verbatim}
%
\section{Að skrifa út breytur}
\label{output}

Þú getur skrifað út gildi breytu með því að nota sömu skipanir og við notuðum til að skrifa út ``einföld'' gildi:

\begin{verbatim}
  int hour, minute;
  char colon;

  hour = 11;
  minute = 59;
  colon = ':';

  cout << "The current time is ";
  cout << hour;
  cout << colon;
  cout << minute;
  cout << endl;
\end{verbatim}
%
Þetta forrit býr til tvær heiltölubreytur með nöfnunum {\tt hour} og {\tt minute}, og stafabreytu með nafninu {\tt colon}.
Forritið gefur þessum breytum viðeigandi gildi og notar síðan runu af úttakssetningum til að skrifa út eftirfarandi: 

\begin{verbatim}
The current time is 11:59
\end{verbatim}

Þegar við tölum um að ``skrifa út breytu'' þá eigum við við að skrifa út 
{\em gildi} breytunnar.
Til að skrifa út {\em nafn} breytu þurfum við að setja nafnið inni í gæsalappir, t.d. {\tt cout << "hour";}

Eins og við höfum áður séð þá er hægt að hafa fleiri en eitt gildi í einni og sömu úttakssetningunni.
Það gerir forritið að ofan ``hnitmiðaðra'' (e. concise):

\begin{verbatim}
  int hour, minute;
  char colon;

  hour = 11;
  minute = 59;
  colon = ':';

  cout << "The current time is " << hour << colon << minute << endl;
\end{verbatim}
%
Í einni og sömu línunni skrifar þetta forrit út streng, tvær heiltölur, staf og sérstaka gildið {\tt endl} -- þetta er mjög áhrifamikið!

\section{Lykilorð}
\index{lykilorð}

Ég nefndi að ofan að þú gætir gefið breytum hvaða nafn sem þér dettur í hug, en það er ekki alls kostar rétt.
Það eru nefnilega nokkur orð í C++ sem er frátekin vegna þess að þau eru notuð af þýðandanum til að þátta forritið þitt og ef þú notar þessi nöfn fyrir breytunöfn þá ``ruglast'' þýðandinn.
Meðal þessara nafna, sem kölluð eru {\bf lykilorð} (e. keywords), eru {\tt int},
{\tt char}, {\tt void}, {\tt endl} og mörg fleiri.

Heildarlistinn yfir lykilorð má finna í C++ staðlinum, sem er obinbera skilgreiningin á málinu samþykkt af 
``International Organization for Standardization (ISO)'', þann 1. september 1998.
Hægt er að hlað niður afriti af staðlinum frá 
\begin{verbatim}
    http://www.ansi.org/
\end{verbatim}
%
Í stað þess að læra listann af lykilorðum utan að þá legg ég til að þú nýtir þér eiginleikann sem boðið er upp á í mörgum þróunarumhverfum, þ.e. ``code highlighting''.
Þetta merkir að þegar þú forritar þá birtast mismunandi hlutar forritsins í mismunandi litum.
Til að mynda gætu lykilorð birst í bláum lit, strengir í rauðum og annar kóði í svörtum.
Ef þú býrð til breytunafn sem birtist í bláum lit þá veistu að um lykilorð er að ræða!
Í því tilviki mun þýðandinn væntanlega ``hegða sér'' undarlega.

\section{Virkjar}
\index{virki}

{\bf Virkjar} (e. operators) eru sérstök tákn sem standa fyrir einfalda útreikninga eins og samlagningu og margföldun.
Flestir virkjar í C++ gera nákvæmalega það sem þú myndir búast við vegna þess að þeir eru þekkt stærðfræðitákn.
T.d. er {\tt +} notað til að leggja saman tvær heiltölur.

Hér má sjá dæmi um leyfilegar segðir (e. expressions) hvers merking ætti að vera augljós:

\begin{verbatim}
1+1        hour-1       hour*60 + minute     minute/60
\end{verbatim}
%
Segðir geta bæði innhaldið breytunöfn og gildi.
Í sérhverju tilviki er nafn breytu skipti út fyrir gildi hennar áður en útreikningurinn er framkvæmdur.

\index{segð}

Samlagning, frádráttur og margföldun skila því sem búast má við en deiling gæti komið á óvart!
Þetta forrit:

\begin{verbatim}
  int hour, minute;
  hour = 11;
  minute = 59;
  cout << "Number of minutes since midnight: ";
  cout << hour*60 + minute << endl;
  cout << "Fraction of the hour that has passed: ";
  cout << minute/60 << endl;
\end{verbatim}
%
myndi skila eftirfarandi úttaki:

\begin{verbatim}
Number of minutes since midnight: 719
Fraction of the hour that has passed: 0
\end{verbatim}
%
Fyrri línan í úttakinu er það sem við mátti búast en seinni línan er skrýtin.
Gildi breytunnar {\tt minute} er 59 og 59 deilt með 60 er 0,98333 en ekki 0.
Ástæðan fyrir þessu misræmi er sú að C++ framkvæmir það sem kallast {\bf heiltöludeiling} (integer division).

\index{tag!int}
\index{heiltöludeiling}
%\index{arithmetic!integer}
\index{deiling!heiltölur}
\index{þolandi}

Þegar báðir {\bf þolendur} (e. operands) virkja eru heiltölur þá verður niðurstaðan líka heiltala.
Samkvæmt skilgreiningu er niðurstaða heiltöludeilingar rúnuð {\em niður} jafnvel þó næsta heiltala sé mjög ``nálægt''.

Í þessu dæmi væri mögulegt að reikna út prósentur í stað almenns brots:

\begin{verbatim}
  cout << "Percentage of the hour that has passed: ";
  cout << minute*100/60 << endl;
\end{verbatim}
%
Niðurstaðan er:

\begin{verbatim}
Percentage of the hour that has passed: 98
\end{verbatim}
%
Í þessu tilviki er niðurstaðan líka rúnuð niður en nú er svarið aftur á móti um það bil rétt.
Til að fá enn réttara svar getum við notað annað tag á breytu en heiltölutag, þ.e. kommutölutag (e. floating-point type).
Kommutölubreytur geta geymt brot en við munum skoða kommutölur betur í næsta kafla.

\section{Forgangur aðgerða}
\index{forgangur}
%\index{order of operations}

Þegar fleiri en einn virki er notaður í segð þá fer röð aðgerðanna eftir reglum um {\bf forgang} (e. precedence).
Nákvæm skýring á forgangsreglum getur verið flókin en svona til að byrja með:

\begin{itemize}

\item Margföldun og deiling hafa hærri forgang en samlagning og frádráttur.
M.ö.o. margfjöldun og deiling eru framkvæmdar áður en samlagning og frádráttur.
Þannig er útkoman úr {\tt 2*3-1} 5 en ekki 4 og {\tt
2/3-1} skilar -1 en ekki 1 (útkoman úr heiltöludeilingunni {\tt 2/3} er 0).

\item Ef virkjar hafa sama forgang þá eru þeim beitt frá vinstri til hægri.
Í segðinni {\tt minute*100/60} er margfjölduninni beitt fyrst sem skilar {\tt 5900/60} og lokaniðurstaðan verður þá {\tt 98}.
Ef virkjunum væri beitt frá hægri til vinstri þá yrði niðurstaðan {\tt 59*1} = {\tt 59} sem væri rangt.

\item Ef þú vilt beita annarri forgangsröðun aðgerða en þeirri innbyggðu þá getur þú notað sviga.
Segðir í svigum eru reiknaðar fyrst og því er niðurstaðan úr {\tt 2 * (3-1)} 4.
Einnig er hægt að nota sviga til að gera segðir læsilegri eins og í {\tt (minute * 100) / 60} þó svo að niðurstaðan sé sú sama án þess að nota sviga í þessu tilfelli.

\end{itemize}

\section{Stafavirkjar}
\index{Stafavirkjar}
\index{Virki!stafir}

Það er athyglisvert að hægt er að beita sömu stærðfræðivirkjum á heiltölur og stafir.
Dæmi: 

\begin{verbatim}
  char letter;
  letter = 'a' + 1;
  cout << letter << endl;
\end{verbatim}
%
Þessi forritsbútur skrifar út stafinn {\tt b}.
Þrátt fyrir að það sér í raun setningafræðilega löglegt að margfalda stafi þá er nánast aldrei nauðsyn til að gera það.

Ég hef áður sagt að það sé eingöngu hægt að gefa heiltölubreytum heiltölugildi og stafabreytum stafagildi en það er ekki alveg rétt.
Í ákveðnum tilfellum breytir C++ sjálfkrafa um tög.
Eftirfarandi forritsbútur er til að mynda löglegur:

\begin{verbatim}
  int number;
  number = 'a';
  cout << number << endl;
\end{verbatim}
%
Útkoman er 97 en það er sú tala sem notuð er í C++ til að tákna stafinn {\tt 'a'}.
Samt sem áður er almennt séð góð regla að meðhöndla stafi sem stafi og heiltölur sem heiltölur og aðeins að breyta einu tagi í annað ef nauðsyn krefur.

Sjálfvirk tagbreyting (e. type conversion) er dæmi um þekkt vandamál við hönnun forritunarmáls --
annars vegar er áhersla á {\bf formhyggju} (e. formalism) (skilyrði um að formlegt mál skuli hafa einfaldara reglur með fáum undantekningum) 
og hins vegar áhersla á {\bf þægindi} (e. convenience) (skilyrði um að forritunarmál skuli vera þægilegt í notkun).

Oftar en ekki vinna þægindin sem er yfirleitt gott fyrir vana forritara sem er þá hlíft við strangri formhyggju.
Aftur á móti er það stundum slæmt fyrir byrjendur í forritun sem finnast oft reglurnar vera flóknar og með fjölda undantekninga.
Í þessari bók hef ég reynt að einfalda hlutina með því að leggja áherslu á reglurnar og sleppa að fjalla um margar undantekningar.

\section{Samsetning}
\index{samsetning}
\index{segð}

Hingað til höfum við skoðað einstakar einingar forritunarmáls -- breytur, segðir og setningar -- án þess að ræða hvernig þær eru settar saman.

Einn gagnlegasti eiginleiki forritunarmála er geta þeirra til að setja saman litlar forritseiningar og mynda þannig heildstætt forrit.
Við vitum t.d. hvernig á að margfalda saman heiltölur og við vitum hvernig á að skrifa út gildi; svo vill reyndar til að við getum gert hvort tveggja á sama tíma:

\begin{verbatim}
    cout << 17 * 3;
\end{verbatim}
%
Reyndar ætti ég ekki að segja ``á sama tíma'' því í raun á margföldunin sér stað áður en niðurstaðan er skrifuð út 
en punkturinn er sá að að sérhver segð, sem inniheldur tölur, stafi og breytur, getur verið notuð í úttakssetningu.
Við höfum þegar séð eitt dæmi um þetta:

\begin{verbatim}
  cout << hour*60 + minute << endl;
\end{verbatim}
%
Hvaða segð sem er getur einnig komið fyrir á hægri hlið gildisveitingarsetningar (e. assignment statement): 

\begin{verbatim}
  int percentage;
  percentage = (minute * 100) / 60;
\end{verbatim}
%
Þessi eiginleiki virðist kannski ekki mikilvægur núna en við munum sjá önnur dæmi þar sem samsetning gerir okkur kleift að tjá (e. express) útreikninga á ``snyrtilegan'' og samþjappaðan hátt.

VIÐVÖRUN: 
Það eru takmarkanir á því hvar hægt er að nota segðir.
Þetta á sérstaklega við um vinstri hlið gildisveitingarsetningar sem verður að vera nafn á {\bf breytu} en ekki segð.
Ástæðan er sú að vinstri hliðin stendur fyrir minnissvæði sem geyma mun gildi segðarinnar á hægri hlið.
Aftur á móti standa segðir ekki fyrir minnissvæði heldur eingöngu gildi.
Eftirfarandi er því ekki löglegt: {\tt minute+1 = hour;}.

\section{Orðalisti}

\begin{description}

\item[breyta (e. variable):] Nafn sem stendur fyrir minnissvæði sem geymir gildi. 
Allar breytur í C++ hafa tag sem ákvarðar hvers konar gildi breytan getur geymt. 

\item[gildi (e. value):] Stafur, tala eða aðrir hlutir sem hægt er að geyma í breytu.

\item[tag (e. type):] Mengi af gildum. Tögin sem við höfum þegar séð eru heiltölur ({\tt int}) og stafir ({\tt char}).

\item[lykilorð (e. keyword):]  Frátkeið orð sem notað er af þýðandanum til að þátta (e. parse) forritið.
Dæmi um lykilorð: {\tt int}, {\tt void} og {\tt endl}.

\item[setning (e. statement):] Forritseining sem stendur fyrir tiltekna skipun eða aðgerð.
Þær setningar sem við höfum séð hingað til eru yfirlýsingar, gildisveitingar og úttakssetningar.

\item[yfirlýsing (e. declaration):] Setning sem býr til nýja breytu og tilgreinir tag hennar.

\item[gildisveiting (e. assignment):] Setning sem gefur tiltekinni breytu gildi.

\item[segð (e. expression):] Samsetning breytna, virkja og gilda sem í heild sinni stendur fyrir eitt gildi (niðurstöðu).
Segð hefur tag sem ákvarðast af þeim virkjum og þolendum sem koma fyrir í segðinni. 

\item[virki (e. operator):] Sérstakt tákn sem stendur fyrir tiltekna aðgerð eins og samlagningu eða margföldun.

\item[þolandi (operand):] Eitt af þeim gildum sem virkja er beitt á. 

\item[forgangur (e. precedence):] Segir til um í hvaða röð virkjum er beitt. 

\item[samsetning (e. composition):] Sá eiginleiki að geta sett saman einfaldar segðir og setningar til að tjá flóknar aðgerðir á samþjappaðan hátt.

\index{breyta}
\index{gildi}
\index{tag}
\index{lykilorð}
\index{setning}
\index{gildisveting}
\index{segð}
\index{virki}
\index{þolandi}
\index{samsetning}

\end{description}
