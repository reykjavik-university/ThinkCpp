% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

% This is an Icelandic translation/adaptation of the orginal book by Allen B. Downey

\chapter{Strengir}
\label{strings}

\section{Geymsla fyrir strengi}

Við höfum hingað til séð fimm tegundir af gildum -- boole (e. booleans), stafi (e. characters), heiltölur (e. integers),
kommutölur (e. floating-point numbers) og strengi (e. strings) -- en aðeins fjórar tegundir af breytum -- {\tt bool}, {\tt char}, {\tt int} og {\tt double}.
Við höfum því ekki séð neina leið til að geyma streng í breytu og framkvæma aðgerðir á strengjum.

Það eru reyndar nokkrar tegundir af breytum í C++ sem geta geymt strengi.
Einn þeirra er grunntag, hluti af C++ málinu, sem er stundum kallað ``a native C string.''
Málskipanin fyrir C strengi er dálítið skrýtin og þar sem notkun C strengja krefst þekkingar á atriðum sem við höfum ekki fjallað um þá munum við að mestu leyti sleppa C strengjum.

Strengjatagið sem við munum notað er kallað {\tt string} en það er einn af þeim klösum (e. classes) sem tilheyra C++ Standard Library.
\footnote{Þú veltir því vafalaust fyrir þér hvað ég á við með {\bf klasa}. Við eigum eftir að skoða nokkra kafla í viðbót áður en ég get gefið fullnægjandi skilgreiningu
en að svo stöddu getum við sagt að klasi sé safn falla sem skilgreina aðgerðir sem hægt er að framkvæma á tilteknu tagi.
{\tt string} klasinn inniheldur öll föll sem hægt er að beita á tagið {\tt string}.}

Því miður vill reyndar svo til að við getum ekki algerlega hunsað C strengi.
Á nokkrum stöðum í þessum kafla mun ég benda þér á vandamál sem hægt er að rekast á með því að nota
In a few places in this chapter I will warn you about some problems {\tt string} í stað C stringja.

\section{{\tt string} breytur}

Þú býrð til breytu af taginu {\tt string} á hefðbundin hátt:

\begin{verbatim}
  string first;
  first = "Hello, ";
  string second = "world.";
\end{verbatim}
%
Fyrsta línan lýsir yfir breytu af taginu {\tt string} án þess að gefa henni gildi.
Önnur línan gefur henni strengjagildið \verb+"Hello."+
Þrðja línan bæði yfirlýsing (e. declaration) og gildisveiting (e. assignment), þ.e. upphafsstilling (e. initialization).

Þegar strengjagildi eins og \verb+"Hello, "+ eða \verb+"world."+ koma fyrir þá eru þau venjulega meðhöndluð sem C strengir.
Í þessu tilviki er þeim hins vegar breytt sjálfvirkt í {\tt string} gildi vegna þess að við notum breytur af taginu {\tt string} til að geyma gildin.

Við getum skrifað út strengi á hefðbundin máta: 

\begin{verbatim}
  cout << first << second << endl;
\end{verbatim}
%

Þú þarft að setja hausaskrá (e. header file) fyrir {\tt string} klasann inn í forritið þitt til að geta þýtt þennan kóða:
\begin{verbatim}
  #include <string>
\end{verbatim}

%In order to compile this code, you will have to include the
%header file for the {\tt string} class, and you will have
%to add the file {\tt string} to the list of files you
%want to compile.  The details of how to do this depend on your
%programming environment.

Áður en við höldum lengra þá skaltu slá ofangreint forrit inn og vera viss um að þú getir þýtt það og keyrt.

\section{Útdráttur stafa úr streng}

Strengir eru kallaðir ``strengir'' vegna þess er þeir eru settir saman af röð eða streng af stöfum.
Fyrsta aðgerðin sem við ætlum að framkvæma á streng er að draga út einn af stöfunum.
C++ notar hornklofa (e. square brackets) ({\tt [} og {\tt ]}) fyrir þessa aðgerð:

\begin{verbatim}
  string fruit = "banana";
  char letter = fruit[1];
  cout << letter << endl;
\end{verbatim}
%
Segðin {\tt fruit[1]} gefur til kynna að ég vilji fá staf nr. 1 í strengnum með nafninu {\tt fruit}.
Niðurstaðan er geymd í {\tt char} breytu með nafninu {\tt letter}.
Þegar ég síðan skrifa út gildið á {\tt letter} þá kemur niðurstaðan á óvart:

\begin{verbatim}
a
\end{verbatim}
%
{\tt a} er ekki fyrsti stafurinn í \verb+"banana"+.
Nema að þú sért tölvunarfræðingur!
Af sérstökum ástæðum byrja tölvunarfræðingar alltaf að telja frá núlli.
Núllti stafurinn í \verb+"banana"+ er {\tt b}.
Fyrsti stafurinn í er {\tt a} og annar stafurinn er {\tt n}.

Þannig að ef þú vilt fá núllta stafinn af streng þá þarftu að setja núll inn í hornklofana: 

\begin{verbatim}
  char letter = fruit[0];
\end{verbatim}

\section{Lengd}
\index{strengur!lengd}
\index{lengd!strengur}

Við getum notað {\tt length} fallið til að finna lengd (fjölda stafa) strengs.
Málskipanin sem notuð er til að kalla á þetta fall er dálítið frábrugðin þeirri sem við höfum séð hingað til:

\begin{verbatim}
  int length;
  length = fruit.length();
\end{verbatim}
%
Til að lýsa þessu fallakalli getum við sagt að við séum að {\bf kalla á} (e. invoking) þetta lengdarfall sem tilheyrir streng með nafninu {\tt fruit}.
Þetta hjómar kannski undarlega en við munum sjá mörg önnur dæmi um að kalla á fall sem tilheyrir hlut (e. object).
Málskipanin fyrir þetta er kölluð ``dot notation,'' vegna þess að punktur (e. dot) kemur á milli nafns hlutarins
{\tt fruit}, og nafns fallsins {\tt length}.

{\tt length} tekur engin viðfögn eins og sjá má með tómu svigunum {\tt ()}.
Skilagildið er heiltala, í þessu tilviki 6.
Taktu eftir að það er leyfilegt að hafa breytu með sama nafn og fall. 

Það gæti verið freistandi að reyna eftirfarandi til að draga út síðasta staf í streng:

\begin{verbatim}
  int length = fruit.length();
  char last = fruit[length];       // WRONG!!
\end{verbatim}
%
Þetta gengur ekki vegna þess að það er enginn stafur nr. 6 í \verb+"banana"+.
Þar sem við byrjum að telja í 0 þá eru stafirnir 6 númeraðir frá 0 upp í 5.
Við þurfum að draga 1 frá {\tt length} til að draga út síðasta stafinn.

\begin{verbatim}
  int length = fruit.length();
  char last = fruit[length-1];
\end{verbatim}

\section{Að ferðast eftir}
\index{ferðast eftir}

Þegar unnið er með strengi þá er algengt að byrja á byrjuninni, velja síðan næsta staf, 
framkvæma einhverja aðgerða á honum, og endurtaka þetta þangað til að komið er að enda strengsins.
Þetta vinnslumynstur er kallað {\bf að ferðast eftir} (e. traversal).
Það er einfalt að kóða svona ``rölt'' með {\tt while} setningu:

\begin{verbatim}
  int index = 0;
  while (index < fruit.length()) {
    char letter = fruit[index];
    cout << letter << endl;
    index = index + 1;
  }
\end{verbatim}
%
Þessi lykkja ferðast um í strengnum og skrifar út sérhvern staf í sér línu.
Taktu eftir því að skilyrðið er {\tt index < fruit.length()} sem merkir að þegar {\tt index} er jafnt lengd strengsins þá
er skilyrðið ósatt og meginmál lykkjunnar ekki keyrt.
Síðasti stafurinn sem við drögum út er sá með vísinn (e. index) {\tt fruit.length()-1}.

\index{lykkjubreyta}
\index{breyta!lykkja}
\index{vísir}

Nafn lykkjubreytunnar er {\tt index}.
{\bf index} (eða vísir á íslensku) er breyta eða gildi sem notuð er til að tilgreina eitt stak í röðuðu mengi, í þessu tilviki mengi af stöfum í streng.
Vísirinn tilgreinir hvaða stak maður hefur áhuga á.
Mengið þarf að vera raðað þannig að sérhver stafur hafi vísi og að visir standi fyrir einn tiltekinn staf.

Þú ætti núna, svona til að æfa þig, að skrifa fall sem tekur {\tt string} sem viðfang og skrifar út stafi strengsins í öfugri röð, alla í einni og sömu línunni.

\section{Keyrsluvilla}
\index{villa!keyrsla}
\index{keyrsluvilla}

Í kafla~\ref{run-time} talaði ég um keyrsluvillur, þ.e. villur sem koma ekki fram fyrr en við keyrslu forrits.

Hingað til hefur þú líklega ekki séð margar keyrsluvillur vegna þess að við höfum ekki gert marga hluti sem gætu orsakað keyrsluvillur.
Það breytist núna.
Ef þú notar {\tt []} virkjann og gefur upp vísi sem er negatífur eða stærri en {\tt length-1} þá færðu keyrsluvillu með villuskilaboðum á þessa leið:

\begin{verbatim}
index out of range: 6, string: banana
\end{verbatim}
%
Prófaðu þetta í þínu þróunarumhverfi til að sjá hvernig villuskilaboðin líta út.

\section{{\tt find} fallið}
\index{find}

{\tt string} klasinn býður upp á ýmis önnur föll sem þú getur beitt á strengi.
{\tt find} fallið er eins og andhverfan við {\tt []} virkjann.
Í stað þess að gefa upp vísi og draga út stafinn sem tengist þeim vísi þá tekur {\tt find} fallið staf sem viðfang
og finnur vísinn þar sem viðkomandi stafur finnst.

\begin{verbatim}
  string fruit = "banana";
  int index = fruit.find('a');
\end{verbatim}
%
Þetta dæmi finnur vísinn fyrir stafinn {\tt 'a'} í strengnum {\tt fruit}.
Í þessu tilviki birtist stafurinn þrisvar sinnum í strengnum þannig að það er ekki augljóst hvað {\tt find} eigi að gera.
Samkvæmt skjölun (e. documentation) um fallið þá skilar það vísinum á {\em fyrsta} tilvikinu, þannig að hér er niðurstaðan 1.
Ef uppgefinn stafur finnst ekki í strengnum þá skilar {\tt find} -1.

Önnur útgáfa af {\tt find} er til sem tekur annan {\tt string} (hlutstreng) sem viðfang og finnur vísinn sem samsvarar því hvar hlutstrengurinn byrjar í strengnum.
Dæmi:

\begin{verbatim}
  string fruit = "banana";
  int index = fruit.find("nan");
\end{verbatim}
%
Í þessu dæmi er niðurstaðan 2.

Þú ættir að muna frá kafla~\ref{overloading} að hægt er að vera með fleiri en eitt fall með sama nafni,
svo framarlega sem þau taka mismunandi fjölda viðfanga eða mismunandi tög.
Í þessu tilvik veit C++ þýðandinn hvora útgáfuna af {\tt find} verið er að nota með því að skoða tög viðfanganna í kallinu.

\section{Our own version of {\tt find}}

If we are looking for a letter in an {\tt string}, we may
not want to start at the beginning of the string.  One way
to generalize the {\tt find} function is to write a version
that takes an additional parameter---the index where we should
start looking.  Here is an implementation of this function.

\begin{verbatim}
int find (string s, char c, int i)
{
  while (i<s.length()) {
    if (s[i] == c) return i;
    i = i + 1;
  }
  return -1;
}
\end{verbatim}
%
Instead of invoking this function on an {\tt string}, like
the first version of {\tt find}, we have to pass the {\tt string}
as the first argument.  The other arguments are the character
we are looking for and the index where we should start.

\section{Talning}
\label{loopcount}
\index{ferðast um!talning}
\index{lykkja!talning}

Eftirfarandi forrit telur fjölda tilvika af stafnum {\tt 'a'} í streng:

\begin{verbatim}
  string fruit = "banana";
  int length = fruit.length();
  int count = 0;

  int index = 0;
  while (index < length) {
    if (fruit[index] == 'a') {
      count = count + 1;
    }
    index = index + 1;
  }
  cout << count << endl;
\end{verbatim}
%
Þetta forrit er gott dæmi um notkun á {\bf teljara} (e. counter).
Breytan {\tt count} er upphafsstillt með núlli og síðan hækkuð í sérhvert sinn sem við finnum stafinn {\tt 'a'}.
(Á ensku er talað um {\bf to increment}, þ.e. að hækka um einn, sem er andstæðan við {\bf to decrement}, að lækka um einn.)
Þegar við hættum í lykkjunni þá mun {\tt count} innihalda niðurstöðuna: fjöldann af stafnum {\tt 'a'}.

\index{teljari}
\index{hækka}
\index{lækka}

Svona til að æfa þig þá skaltu núna hjúpa þennan kóða sem fall með nafninu {\tt countLetters} og beita síðan alhæfingu (gera fallið almennt)
þannig að það taki við streng og staf sem viðföngum.

\index{hjúpun}
\index{alhæfing}

%As a second exercise, rewrite this function so that instead
%of traversing the string, it uses the version of
%{\tt find} we wrote in the previous section.

\section{``Increment'' og ``decrement'' virkjar}
\index{virki!auki}
\index{virki!frádrag}

Það að bæta við einum (e. incrementing) og draga einn frá (e. decrementing) eru svo algengar aðgerðir að C++ býður upp á sértaka virkja fyrir þær.
{\tt ++} virkinn (sem kalla má ``auki'' á íslensku) bætir einum við núverandi gildi á {\tt int}, {\tt char} eða {\tt double}, og
{\tt --} (sem kalla má ``frádrag'' á íslensku) dregur einn frá.
Hvorugur virkjanna virkar á {\tt string} og hvorugum þeirra {\em ætti} að beita á {\tt bool}.

Tæknilega séð er löglegt að hækka breytu og nota hana í segð á sama tíma.
Þú gætir t.d. séð svona kóða: 

\begin{verbatim}
  cout << i++ << endl;
\end{verbatim}
%
Þegar við horfum á þetta þá er ekki ljóst hvort hækkun breytunnar muni eiga sér stað fyrir eða eftir að gildi hennar er skrifað út.
Ég mæli ekki með að þú notir {\tt ++} eða {\tt --} á þennan hátt því þessi notkun getur valdið ruglingi.
Reyndar ætla ég ekki að segja hver niðurstaðan er.  
Þú verður bara að prófa þetta ef þú iðar í skinninu að vita það!

Með því að nota virkjann auki (e. increment) getum við endurskrifað kóðann sem telur tilvik af staf:

\begin{verbatim}
  int index = 0;
  while (index < length) {
    if (fruit[index] == 'a') {
      count++;
    }
    index++;
  }
\end{verbatim}
%
Algeng villa er að skrifa eitthvað á þessa leið:

\begin{verbatim}
  index = index++;             // WRONG!!
\end{verbatim}
%
Því miður vill svo til að þetta er málfræðilega rétt og því mun þýðandinn ekki gera neinar athugasemdir.
Niðurstaðan af þessari setningu er sú að gildið á {\tt index} helst óbreytt.
Það er oft erfitt að finna þessa villu.

Mundu að þú getur skrifað {\tt index = index +1;} eða {\tt index++;} -- þú ættir hins vegar ekki að blanda þessu tvennu saman.

\section{Samskeyting strengja}

Það er athyglisvert að hægt er að beita virkjanum {\tt +} á strengi -- virkinn framkvæmir {\bf samskeytingu} (e. concatenation).
Samskeyting merkir að skeyta saman tveimur (eða fleiri) strengjum.
Dæmi:

\begin{verbatim}
  string fruit = "banana";
  string bakedGood = " nut bread";
  string dessert = fruit + bakedGood;
  cout << dessert << endl;
\end{verbatim}
%
Úttakið úr þessu forriti er {\tt banana nut bread}.

Því miður virkar {\tt +} virkinn hins vegar ekki á ``native C'' strengi og því er ekki hægt að skrifa

\begin{verbatim}
  string dessert = "banana" + " nut bread";
\end{verbatim}
%
vegna þess að báðir þolendur {\tt +} virkjans eru hér C strengir (\verb+"banana"+ og \verb+" nut bread"+).
Svo framarlega sem annar þolandanna er {\tt string} þá mun C++ reyndar breyta hinum sjálfvirkt í {\tt string}.

Það er líka mögulegt að skeyta stökum staf við byrjun eða enda á {\tt string}.
Í eftirfarandi dæmi notum við samskeytingu og stafareikning (e. character arithmetic) til að skrifa út ``abecedarian'' röð.

``Abecedarian'' vísar til röð eða lista hvers stök eru í stafrófsröð.
Í bók Robert McCloskey's {\em Make Way for Ducklings} eru t.d. nöfn andarunganna Jack,
Kack, Lack, Mack, Nack, Ouack, Pack og Quack.
Hér er lykkja sem skrifar út þessi nöfn í réttri röð: 

\begin{verbatim}
  string suffix = "ack";

  char letter = 'J';
  while (letter <= 'Q') {
    cout << letter + suffix << endl;
    letter++;
  }
\end{verbatim}
%
Úttak forritsins er:

\begin{verbatim}
Jack
Kack
Lack
Mack
Nack
Oack
Pack
Qack
\end{verbatim}
%
Auðvitað er þetta ekki alveg rétt því ``Ouack'' og ``Quack'' skrifast ekki alveg rétt út.
Þú ættir að breyta forritinu og leiðrétta þessa villu.

Hér þurfum við aftur að passa okkur að nota samskeytingu aðeins með {\tt string} taginu en ekki með ``native C'' strengjum.
Því miður er segð eins og {\tt letter} + \verb+"ack"+ málfræðilega rétt í C++ en útkoman er mjög skrýtin, a.m.k. í mínu þróunarumhverfi.

\section{{\tt string}s are mutable}
\index{class!string}
\index{immutable}
\index{string}

You can change the letters in an {\tt string} one at a time
using the {\tt []} operator on the left side of an assignment.
For example,

\begin{verbatim}
  string greeting = "Hello, world!";
  greeting[0] = 'J';
  cout << greeting << endl;
\end{verbatim}
%
produces the output {\tt Jello, world!}.


\section{{\tt string}s are comparable}
\label{incomparable}
\index{class!string}
\index{comparison!string}
\index{string}

All the comparison operators that work on {\tt int}s and
{\tt double}s also work on {\tt strings}.  For example,
if you want to know if two strings are equal:

\begin{verbatim}
  if (word == "banana") {
    cout << "Yes, we have no bananas!" << endl;
  }
\end{verbatim}
%
The other comparison operations are useful for putting words
in alphabetical order.

\begin{verbatim}
  if (word < "banana") {
    cout << "Your word, " << word << ", comes before banana." << endl;
  } else if (word > "banana") {
    cout << "Your word, " << word << ", comes after banana." << endl;
  } else {
    cout << "Yes, we have no bananas!" << endl;
  }
\end{verbatim}
%
You should be aware, though, that the {\tt string} class does
not handle upper and lower case letters the same way that people
do.  All the upper case letters come before all the lower case
letters.  As a result,

\begin{verbatim}
Your word, Zebra, comes before banana.
\end{verbatim}
%
A common way to address this problem is to convert strings to a
standard format, like all lower-case, before performing the
comparison.  The next sections explains how.  I will not address the
more difficult problem, which is making the program realize that
zebras are not fruit.

\section{Character classification}

It is often useful to examine a character and test whether
it is upper or lower case, or whether it is a character or
a digit.  C++ provides a library of functions that perform
this kind of character classification.  In order to use these
functions, you have to include the header file {\tt ctype.h}.

\begin{verbatim}
  char letter = 'a';
  if (isalpha(letter)) {
    cout << "The character " << letter << " is a letter." << endl;
  }
\end{verbatim}
%
You might expect the return value from {\tt isalpha} to
be a {\tt bool}, but for reasons I don't even want to think
about, it is actually an integer that is
0 if the argument is not a letter, and some non-zero value
if it is.

This oddity is not as inconvenient as it seems, because it is
legal to use this kind of integer in a conditional, as shown
in the example.  The value 0 is treated as {\tt false}, and
all non-zero values are treated as {\tt true}.

Technically, this sort of thing should not be allowed---integers are
not the same thing as boolean values.  Nevertheless, the C++ habit of
converting automatically between types can be useful.

Other character classification functions include {\tt isdigit}, which
identifies the digits 0 through 9, and {\tt isspace}, which identifies
all kinds of ``white'' space, including spaces, tabs, newlines, and a
few others.  There are also {\tt isupper} and {\tt islower}, which
distinguish upper and lower case letters.

Finally, there are two functions that convert letters from one
case to the other, called {\tt toupper} and {\tt tolower}.  Both take
a single character as a parameter and return a (possibly
converted) character.

\begin{verbatim}
  char letter = 'a';
  letter = toupper (letter);
  cout << letter << endl;
\end{verbatim}
%
The output of this code is {\tt A}.

As an exercise, use the character classification and conversion
library to write functions named {\tt stringToUpper} and
{\tt stringToLower} that take a single {\tt string} as
a parameter, and that modify the string by converting all the
letters to upper or lower case.  The return type should be
{\tt void}.

\section{Other {\tt string} functions}

This chapter does not cover all the {\tt string} functions.
Two additional ones, {\tt c\_str} and {\tt substr}, are covered
in Section~\ref{finput} and Section~\ref{parsing}.

\section{Glossary}

\begin{description}

\item[object:] A collection of related data that comes with a set of
functions that operate on it.  The objects we have used so far are the
{\tt cout} object provided by the system, and {\tt string}s.

\item[index:]  A variable or value used to select one of the
members of an ordered set, like a character from a string.

\item[traverse:]  To iterate through all the elements of a set
performing a similar operation on each.

\item[counter:]  A variable used to count something, usually
initialized to zero and then incremented.

\item[increment:]  Increase the value of a variable by one.
The increment operator in C++ is {\tt ++}.  In fact, that's
why C++ is called C++, because it is meant to be one better
than C.

\item[decrement:]  Decrease the value of a variable by one.
The decrement operator in C++ is {\tt --}.

\item[concatenate:] To join two operands end-to-end.

\index{object}
\index{index}
\index{traverse}
\index{counter}
\index{increment}
\index{decrement}
\index{concatenate}

\end{description}

