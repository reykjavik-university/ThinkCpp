% LaTeX source for textbook ``How to think like a computer scientist''
% Copyright (C) 1999  Allen B. Downey

% This LaTeX source is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License as
% published by the Free Software Foundation (version 2).

% This LaTeX source is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
% General Public License for more details.

% Compiling this LaTeX source has the effect of generating
% a device-independent representation of a textbook, which
% can be converted to other formats and printed.  All intermediate
% representations (including DVI and Postscript), and all printed
% copies of the textbook are also covered by the GNU General
% Public License.

% This distribution includes a file named COPYING that contains the text
% of the GNU General Public License.  If it is missing, you can obtain
% it from www.gnu.org or by writing to the Free Software Foundation,
% Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

% This is an Icelandic translation/adaptation of the orginal book by Allen B. Downey

\chapter{Vektorar af hlutum}

\section{Samsetning}
\index{samsetning}
\index{hreiðruð skipan}

Hingað til höfum við séð nokkur dæmi um samsetningu (e. composition), þ.e. þegar einstakir eiginleikar forritunarmálsins eru settir saman á ýmsan máta.
Eitt af fyrstu dæmunum sem við sáum var að nota fallakall sem hluta af segð (e. expression).
Annað dæmi er hreiðruð skipan setninga: hægt er að setja {\tt if} setningu inn í {\tt while} lykkju eða inn í aðra {\tt if} setningu, o.s.frv.

Nú þegar við höfum séð þessi samsetningarmynstur, og lært um vektorara og hluti, þá ætti ekki að koma á óvart að hægt er að búa til vektora af hlutum.
Reyndar vill svo til að það er líka hægt að búa til hluti sem innihalda vektora (sem meðlimabreytur) vektora sem innihalda vektora; hluti sem innihalda aðra hluti, o.s.frv.

Í næstu tveimur köflum munum við skoða nokkur dæmi um svona samsetningar með því að nota {\tt Card} hluti sem sýnidæmi. 

\section{{\tt Card} hlutir}
\index{Card}
\index{hlutur!Card}

Ef þú þekkir ekki handspil (e. playing cards) þá er nú góður tímapunktur að sækja spilastokk (e. deck) því annars er hætt við því að efni þessa kafla fari fyrir ofan garð og neðan.
Það eru 52 spil í spilastokki og sérhvert spil tilheyrir einum af fjórum litum (e. suit) og 13 gildum (e. rank).
Litirnir eru (í lækkandi röð í bridds): Spaðar (e. Spades), hjörtu (e. Hearts), tíglar (e. Diamonds) og lauf (e. Clubs).
Gildin eru ás (e. Ace), 2, 3, 4, 5, 6, 7, 8, 9, 10, gosi (e. Jack), drottning (e. Queen) og kóngur (e. King).
Það fer eftir því hvaða spil þú ert að spila hvort ásinn er hærri en kóngur eða lægri en tvistur.

\index{gildi}
\index{rank}
\index{litur}
\index{suit}

Það er nokkuð augljóst hverjar meðlimabreyturnar eiga að vera ef við viljum skilgreina nýjan hlut sem stendur fyrir tiltekið spil: {\tt rank} og {\tt suit}.
Það er hins vegar ekki jafn augljóst hvert tag meðlimabreytnanna ætti að vera.
Einn möguleiki er að nota {\tt string} sem þá myndi innihalda t.d. \verb+"Spade"+ fyrir lit og \verb+"Queen"+ fyrir gildi.
Eitt vandamálið við þá útfærslu er að það yrði ekki einfalt að bera saman tvö spil, þ.e. að finna út hvort þeirra er með hærri lit eða hærra gildi.

\index{kóta}
\index{varpa}

Annar möguleiki er sá að nota heiltölur til að {\bf kóta} (e. encode) gildin og litina. 
Það sem tölvunarfræðingar eiga við með ``að kóta'' er t.d. að skilgreina vörpun á milli talnarunu og hlutanna sem sérhvert tala raðarinnar stendur fyrir.
Dæmi:

\vspace{0.1in}
\begin{tabular}{l c l}
Spades & $\mapsto$ & 3 \\
Hearts & $\mapsto$ & 2 \\
Diamonds & $\mapsto$ & 1 \\
Clubs & $\mapsto$ & 0
\end{tabular}
\vspace{0.1in}

Táknið $\mapsto$ er stærðfræðileg tákn fyrir ``varpast í''. 
Það má augljóslega lesa úr þessari vörpun að litirnir varpast í heiltölur í ákveðinni röð.
Þannig getum við borið saman liti með því að bera saman heiltölur.
Vörpunin fyrir gildi eru nokkuð augljós: sérhvert spil með talnagildi varpast yfir í viðkomandi heiltölu en fyrir mannspil notum við eftirfarandi vörpun:

\vspace{0.1in}
\begin{tabular}{l c l}
Jack & $\mapsto$ & 11 \\
Queen & $\mapsto$ & 12 \\
King & $\mapsto$ & 13 \\
\end{tabular}
\vspace{0.1in}

Ástæðan fyrir því að ég nota stærðfræðilega táknun fyrir þessar varpanir er sú að þær eru ekki hluti af C++ forritunarmálinu.
Varpanirnar eru hluti af hönnun forritsins en þær koma ekki beint fyrir í forritskóðanum.
Strúktúrskilgreiningin fyrir {\tt Card} tagið lítur svona út:

\begin{verbatim}
struct Card
{
  int suit, rank;

  Card ();
  Card (int s, int r);
};

Card::Card () { 
  suit = 0;  rank = 0;
}

Card::Card (int s, int r) { 
  suit = s;  rank = r;
}
\end{verbatim}
%
Það eru tveir smiðir (e. constructors) fyrir {\tt Card}.
Þú sérð að um er að ræða smiði vegna þess að þeir hafa ekkert skilagildi og nafn þeirra er það sama og nafn strúktúrsins.
Fyrri smiðurinn tekur engin viðföng og upphafsstillir meðlimabreyturnar í raun með gagnlausum gildum (0 í laufi!).

Seinni smiðurinn er gagnlegri.
Hann tekur tvö viðföng, lit og gildi spilsins.

\index{smiður}

Eftirfarandi kóði býr til hlut með nafninu {\tt threeOfClubs} sem stendur fyrir laufaþrist: 

\begin{verbatim}
   Card threeOfClubs (0, 3);
\end{verbatim}
%
Fyrsta viðfangið, {\tt 0}, stendur fyrir litinn lauf og seinna viðfangið fyrir gildið 3.

\section{{\tt printCard} fallið}
\index{printCard}
\index{print!Card}

Fyrsta skrefið í því að búa til nýtt tag felst yfirleitt í því að lýsa yfir meðlimabreytum og skrifa smiði.
Annað skrefið felst oft í því að skrifa út viðkomandi hlut á læsilegan máta (e. human-readable).

\index{string!vektor af}
\index{vector!af string}

Í tilviki {\tt Card} hlutanna þá merkir ``læsilegur máti'' að við verðum að varpa innri framsetningu litar og gildis í orð.
Eðlileg leið til að gera það er að nota vektor af strengjum ({\tt string}).
Þú getur búið til vektor af strengjum á sama hátt og þú býrð til vektor af hvaða öðru tagi sem er:

\begin{verbatim}
  vector<string> suits (4);
\end{verbatim}
%
%Of course, in order to use {\tt apvector}s and {\tt apstring}s, you
%will have to include the header files for both\footnote{{\tt apvector}s
%are a little different from {\tt apstring}s in this regard.
%The file {\tt apvector.cpp} contains a template that allows the
%compiler to create vectors of various kinds.  The first time you
%use a vector of integers, the compiler generates code
%to support that kind of vector.  If you use a vector of {\tt apstring}s,
%the compiler generates different code to handle that kind of
%vector.  As a result, it is usually sufficient to include the
%eader file {\tt apvector.h}; you do not have to compile
%{\tt apvector.cpp} at all!  Unfortunately, if you do, you are
%likely to get a long stream of error messages.  I hope this
%footnote helps you avoid an unpleasant surprise, but the details
%in your development environment may differ.}.

Við getum notað röð gildisveitingarsetninga (e. assignment statements) til að upphafsstilla stök vektors:

\begin{verbatim}
  suits[0] = "Clubs";
  suits[1] = "Diamonds";
  suits[2] = "Hearts";
  suits[3] = "Spades";
\end{verbatim}
%
Stöðurit frir þennan vektor lítur þá svona út: 

\index{stöðurit}

\vspace{0.1in}
\centerline{\epsfig{figure=apstringvector.eps}}
\vspace{0.1in}

Við getum búið til sambærilegan vektor til að afkóta (e. decode) gildin.
Þá getum við valið viðeigandi stök með því að nota {\tt suit} og {\tt rank} sem vísa (e. indices).
Að lokum getum við síðan skrifað fallið {\tt print} sem skrifar út spilið:

\begin{verbatim}
void Card::print () const
{
  vector<string> suits (4);
  suits[0] = "Clubs";
  suits[1] = "Diamonds";
  suits[2] = "Hearts";
  suits[3] = "Spades";

  vector<string> ranks (14);
  ranks[1] = "Ace";
  ranks[2] = "2";
  ranks[3] = "3";
  ranks[4] = "4";
  ranks[5] = "5";
  ranks[6] = "6";
  ranks[7] = "7";
  ranks[8] = "8";
  ranks[9] = "9";
  ranks[10] = "10";
  ranks[11] = "Jack";
  ranks[12] = "Queen";
  ranks[13] = "King";

  cout << ranks[rank] << " of " << suits[suit] << endl;
}
\end{verbatim}
%
Segðin {\tt suits[suit]} merkir að ``nota meðlimabreytuna {\tt suit} í núverandi hlut sem vísi inn í vektorinn {\tt suits}
og velja viðeigandi streng.''

Vegna þess að {\tt print} er meðlimafall í {\tt Card} þá getur það vísað í meðlimbreytur núverandi hlutar á dulinn hátt (án þess að nota punktatáknun og ``this'' til að tilgreina hlutinn).
Úttakið úr þessum kóða

\begin{verbatim}
  Card card (1, 11);
  card.print ();
\end{verbatim}
%
er {\tt Jack of Diamonds}.

Þú tekur kannski eftir því að við notum ekki núllta stakið í {\tt ranks} vektornum.
Ástæðan er sú að leyfileg gildi eru aðeins þau á bilinu 1--13.
Með því að skilja fyrsta stakið (núllta stakið) eftir ónotað í vektornum þá fáum við vörpun sem varpar 2 í ``2'', 3 í ``3'', o.s.frv.
Notandi verður ekkert var við þessa vörpun (eða innri framsetningu) sem við notum í forritinu því allt inntak og úttak er sett fram á læsilegan hátt.
Á hinn bóginn er það oft þægilegt fyrir forritarann ef vörpun er sett fram á máta sem auðvelt er að muna.

\section{Fallið {\tt equals}}
\index{samanburður}

Tvö spil eru jöfn ef þau eru með sama gildi og bera sama lit.
Því miður getum við ekki notað {\tt ==} virkjann til að bera saman tvö spil
því hann virkar ekki fyrir tög sem notandinn skilgreinir (e. user-defined types) eins og {\tt Card}.
Við verðum því að skrifa fall sem ber saman tvö spil.
Köllum það {\tt equals}.
Það er reyndar hægt að fjölbinda (e. overload) {\tt ==} virkjann en við munu ekki fjalla um þann möguleika í þessari bók. 

Það er ljóst að skilagildið úr {\tt equals} ætti að vera bool gildi sem gefur til kynna hvort tvö spil eru jöfn eður ei.
Það er jafnframt ljóst að fallið þarf að taka tvo {\tt Card} hluti sem viðföng. 
Nú stöndum við frammi fyrir eftirfarandi vali: Á {\tt equals} að vera meðlimafall (e. member function) eða fall sem stendur eitt og sér (e. free-standing function)?

Sem meðlimafall lítur {\tt equals} svona út:

\begin{verbatim}
bool Card::equals (const Card& c2) const
{
  return (rank == c2.rank && suit == c2.suit);
}
\end{verbatim}
%
Til að nota fallið vekjum við það upp með einu spili og sendum hitt spilið sem viðfang: 

\begin{verbatim}
  Card card1 (1, 11);
  Card card2 (1, 11);

  if (card1.equals(card2)) {
    cout << "Yup, that's the same card." << endl;
  }
\end{verbatim}
%
Mér finnst þessi aðferð við vakningu (e. invocation) alltaf líta dálítið undarlega út
þegar um er að ræða fall eins og {\tt equals} þar sem viðföngin tvö eru samhverf (e. symmetric).
Það sem ég á við með samhverf viðföng er að það skiptir ekki máli hvort ég spyr 
``Is A equal to B?'' eða ``Is B equal to A?''.
Í þessu tilviki mér finnst því eðlilegra að skrifa {\tt equals} sem ``ekki-meðlimafall'' (e. nonmember function). 

\begin{verbatim}
bool equals (const Card& c1, const Card& c2)
{
  return (c1.rank == c2.rank && c1.suit == c2.suit);
}
\end{verbatim}
%
Þegar við köllum á þessa útgáfu fallsins þá birtast viðföngin hlið við hlið á máta sem mér finnst eðlilegri.

\begin{verbatim}
  if (equals (card1, card2)) {
    cout << "Yup, that's the same card." << endl;
  }
\end{verbatim}
%
Þetta er samt auðvitað bara spurning um smekk.
Punkturinn hér er sá að þú ættir að geta skrifað hvort sem er meðlimafall eða ``ekki-meðlimafall'' þannig að þú getir ákveðið þau skil (e. interface)
sem eru hentugust því verkefni sem liggur fyrir hverju sinni.

\section{Fallið {\tt isGreater}}
\index{isGreater}
\index{virki!samanburður}
\index{samanburðarvirki}

Fyrir grunntög eins og {\tt int} og {\tt double} eru til innbyggðir samanburðarvirkjar
sem bera saman gildi og ákvarða hvort eitt gildi er stærra eða minna en annað.
Þessir virkjar ({\tt <} og {\tt >} og fleiri) virka hins vegar ekki fyrir tög sem skilgreind eru af notanda.
Við þurfum því, á sama hátt og við gerðum í tilviki {\tt ==} virkjans, að skrifa samanburðarfall sem líkir eftir {\tt >} virkjanum.
Við munum síðar nota þetta fall til að raða spilum spilastokks.

\index{röðun}
%\index{complete ordering}
%\index{partial ordering}
\index{fullröðun}
\index{hlutröðun}

Sum mengi eru fullröðuð (e. totally ordered) sem merkir að hægt er að bera saman hvaða tvö stök sem er og segja til um hvort er stærra.
Heiltölur og kommutölur eru t.d. fullraðaðar.
Sum mengi eru hins vegar ekki röðuð sem merkir að það er engin nærtæk leið til að segja til um hvort eitt stak sé stærra en annað.
Ávextir eru t.d. ekki raðaðir sem er einmitt ástæðan fyrir því að við getum ekki borið saman epli og appelsínur!
Annað dæmi um mengi sem er ekki raðað er {\tt bool} tagið -- við getum ekki sagt að {\tt true} sé stærra en {\tt false}.

Mengi handspila er hlutraðað (e. partially ordered), þ.e. stundum er hægt að bera saman spil og stundum ekki.
Ég veit t.d. að laufaþristur er hærri en laufatvistur vegna þess að sá fyrrnefndi er með hærra gildi en sá síðarnefndi
og að tígulþristur er hærri en laufaþristur vegna þess að sá fyrrnefndi er með hærri lit.
En hvort er laufaþristur eða tígultvistur betra spil?  Annað er með hærra gildi en hitt en með hærri lit.

%\index{comparable}
\index{samanburðarhæfni}

Til að tvö spil séu samanburðarhæf verðum við að ákveða hvort litur eða gildi er mikilvægara 
Ég ætla að segja að litur sé mikilvægari og ástæðan er sú að þegar þú kaupir nýjan spilastokk þá er hann raðaður eftir litum,
þ.e. öll laufin saman, síðan tíglarnir, o.s.frv.

Nú þegar þetta er ákveðið þá getum við skrifað fallið {\tt isGreater}.
Aftur ætti að vera augljóst að viðföngin eru tveir {\tt Card} hlutir og að skilagildið er {\tt bool}.
Við þurfum á ný að velja á milli meðlimafalls og ``ekki-meðlimafalls''.
Í þetta skiptið eru viðföngin ekki samhverf.
Það skipir máli hvort við viljum vita ``Is A greater than B?'' eða ``Is B greater than A?''.
Þess vegna finnst mér eðlilegra að útfæra {\tt isGreater} sem meðlimafall:

\begin{verbatim}
bool Card::isGreater (const Card& c2) const
{
  // first check the suits
  if (suit > c2.suit) return true;
  if (suit < c2.suit) return false;

  // if the suits are equal, check the ranks
  if (rank > c2.rank) return true;
  if (rank < c2.rank) return false;

  // if the ranks are also equal, return false
  return false;
}
\end{verbatim}
%
Þegar við vekjum fallið upp þá er augljóst út frá málskipaninni hvora af hinum tveimur spurningum að ofan við erum að setja fram:

\begin{verbatim}
  Card card1 (2, 11);
  Card card2 (1, 11);

  if (card1.isGreater (card2)) {
    card1.print ();
    cout << "is greater than" << endl;
    card2.print ();
  }
\end{verbatim}
%
Það er nánast hægt að lesa þetta eins og ensku: ``If card1 isGreater card2 ...''
Úttak forritsins er:

\begin{verbatim}
Jack of Hearts
is greater than
Jack of Diamonds
\end{verbatim}
%
Samkvæmt {\tt isGreater} eru ásar lægri en tvistar. 
Þú ættir núna að laga fallið þannig að ásar séu hærri en kóngar eins og þeir eru í flestum spilum.

\section{Vektor af spilum}
\index{vector!af hlutum}
\index{hlutur!vektor af}
\index{spilastokkur}

Ástæðan fyrir því að ég valdi spil ({\tt Cards}) sem hluti í þessum kafla er að það er augljóst notkun fyrir vektor af spilum, þ.e. spilastokkur.
Hér er forritskóði sem býr til nýjan stokk af 52 spilum:

\begin{verbatim}
  vector<Card> deck (52);
\end{verbatim}
%
Og hér er stöðurit fyrir þennan hlut: 

\index{state diagram}

\vspace{0.1in}
\centerline{\epsfig{figure=cardvector.eps}}
\vspace{0.1in}

Punktarnir þrír standa fyrir spilin 48 sem ég sleppti að teikna.
Taktu eftir að við höfum ekki upphafsstillt meðlimabreytur sérhvers spils.
Í sumum keyrsluumhverfum munu þær verða upphafsstilltar sjálfvirkt með núllum (eins og sýnt er á myndinni)
en annars staðar gætu þær fengið hvaða gildi sem er.

Ein leið til að upphafsstilla meðlimabreyturnar er að senda {\tt Card} hlut sem annað viðfang í smiðinn:

\begin{verbatim}
  Card aceOfSpades (3, 1);
  vector<Card> deck (52, aceOfSpades);
\end{verbatim}
%

Þessi forritskóði býr til stokk me 52 eins spilum, svona eins og gæti verið notaður í töfrabragði!
Það er auðvitað eðlilegra að búa til stokk með 52 mismunandi spilum í.
Við getum gert það með því að nota hreiðraða (e. nested) lykkju.

\index{lykkja!hreiðruð}
\index{hreiðruð lykkja}

Ytri lykkjan ``telur upp'' (e. enumerates) litina, frá 0 til 3.
Fyrir hvern lit telur innri lykkjan upp gildin, frá 1 til 13.
Þar sem ytri lykkjan keyrir fjórum sinnum og innri lykkjan 13 sinnum þá keyrir meginmál (e. body) lykkjunnar samtals 52 sinnum (13*4).

\begin{verbatim}
  int i = 0;
  for (int suit = 0; suit <= 3; suit++) {
    for (int rank = 1; rank <= 13; rank++) {
      deck[i].suit = suit;
      deck[i].rank = rank;
      i++;
    }
  }
\end{verbatim}
%
Ég notaði breytuna {\tt i} til að halda utan um í hvaða sæti í spilastokknum næsta spil ætti að fara. 

\index{vísir}

Taktu eftir því að við getum sett saman málskipanina til að velja stak úr fylki (með {\tt []} virkjanum)
og málskipanina sem velur meðlimabreytu úr hlut (punkta táknið).
Segðin {\tt deck[i].suit} merkir þá ``the suit of the ith card in the deck''.

\index{hjúpun}

Til að æfa þig ættir þú nú að hjúpa ofangreindan kóða í fall sem kallast {\tt buildDeck}.
Fallið tekur engin viðföng og skilar vektor af {\tt Card} sem hefur verið upphafsstilltur með 52 spilum.

\section{Fallið {\tt printDeck}}
\label{printdeck}
\index{printDeck}
\index{print!vektor af spilum}

Þegar unnið er með vektor þá er þægilegt að eiga fall sem skrifar út innihald vektorsins.
Við höfum nokkrum sinnum séð mynstur til að ``ferðast um'' í vektor þannig að eftirfarandi fall ætti að vera kunnuglegt:

\begin{verbatim}
void printDeck (const vector<Card>& deck) {
  for (int i = 0; i < deck.length(); i++) {
    deck[i].print ();
  }
}
\end{verbatim}
%
Það ætti heldur ekki að koma á óvart að við getum sett saman málskipanina til að nálgast stak í vektor og málskipanina til að vekja upp fall.

Þar sem {\tt deck} hefur tagið {\tt vector<Card>} þá hefur stak í {\tt deck} tagið {\tt Card}.
Þess vegna er leyfilegt að vekja upp fallið {\tt print} með {\tt deck[i]}.

\section{Searching}
\label{find}
\index{searching}
\index{linear search}
\index{find}

The next function I want to write is {\tt find}, which searches
through a vector of {\tt Card}s to see whether it contains a certain
card.  It may not be obvious why this function would be useful, but it
gives me a chance to demonstrate two ways to go searching for things,
a {\tt linear} search and a {\tt bisection} search.

\index{traverse}
\index{loop!search}

Linear search is the more obvious of the two; it involves traversing
the deck and comparing each card to the one we are looking for.  If we
find it we return the index where the card appears.  If it is not in
the deck, we return -1.

\begin{verbatim}
int find (const Card& card, const apvector<Card>& deck) {
  for (int i = 0; i < deck.length(); i++) {
    if (equals (deck[i], card)) return i;
  }
  return -1;
}
\end{verbatim}
%
The loop here is exactly the same as the loop in {\tt printDeck}.
In fact, when I wrote the program, I copied it, which saved me
from having to write and debug it twice.

Inside the loop, we compare each element of the deck to
{\tt card}.  The function returns as soon as it discovers
the card, which means that we do not have to traverse the entire
deck if we find the card we are looking for.  If the loop terminates
without finding the card, we know the card is not in the deck
and return {\tt -1}.

\index{pattern!eureka}
\index{statement!return}
\index{return!inside loop}

To test this function, I wrote the following:

\begin{verbatim}
  apvector<Card> deck = buildDeck ();

  int index = card.find (deck[17]);
  cout << "I found the card at index = " << index << endl;
\end{verbatim}
%
The output of this code is

\begin{verbatim}
I found the card at index = 17
\end{verbatim}
%


\section{Bisection search}
\index{bisection search}

If the cards in the deck are not in order, there is no way to search
that is faster than the linear search.  We have to look at every card,
since otherwise there is no way to be certain the card we want is not
there.

But when you look for a word in a dictionary, you don't search
linearly through every word.  The reason is that the words are in
alphabetical order.  As a result, you probably use an algorithm that
is similar to a bisection search:

\begin {enumerate}

\item Start in the middle somewhere.

\item Choose a word on the page and compare it to the word you
are looking for.

\item If you found the word you are looking for, stop.

\item If the word you are looking for comes after the word on
the page, flip to somewhere later in the dictionary and go to
step 2.

\item If the word you are looking for comes before the word on
the page, flip to somewhere earlier in the dictionary and go to
step 2.

\end {enumerate}

If you ever get to the point where there are two adjacent words on the
page and your word comes between them, you can conclude that your word
is not in the dictionary.  The only alternative is that your word has
been misfiled somewhere, but that contradicts our assumption that the
words are in alphabetical order.

In the case of a deck of cards, if we know that the cards are in
order, we can write a version of {\tt find} that is much faster.  The
best way to write a bisection search is with a recursive function.
That's because bisection is naturally recursive.

\index{findBisect}

The trick is to write a function called {\tt findBisect} that takes
two indices as parameters, {\tt low} and {\tt high}, indicating the
segment of the vector that should be searched (including both
{\tt low} and {\tt high}).

\begin{enumerate}

\item To search the vector, choose an index between {\tt low} and {\tt
high}, and call it {\tt mid}.  Compare the card at {\tt mid} to the
card you are looking for.

\item If you found it, stop.

\item If the card at {\tt mid} is higher than your card, search
in the range from {\tt low} to {\tt mid-1}.

\item If the card at {\tt mid} is lower than your card, search
in the range from {\tt mid+1} to {\tt high}.

\end{enumerate}
%
Steps 3 and 4 look suspiciously like recursive
invocations.  Here's what this all looks like translated into
C++:

\begin{verbatim}
int findBisect (const Card& card, const apvector<Card>& deck,
                int low, int high) {
  int mid = (high + low) / 2;

  // if we found the card, return its index
  if (equals (deck[mid], card)) return mid;

  // otherwise, compare the card to the middle card
  if (deck[mid].isGreater (card)) {
    // search the first half of the deck
    return findBisect (card, deck, low, mid-1);
  } else {
    // search the second half of the deck
    return findBisect (card, deck, mid+1, high);
  }
}
\end{verbatim}
%
Although this code contains the kernel of a bisection search, it
is still missing a piece.  As it is currently written,
if the card is not in the deck, it will recurse forever.  We
need a way to detect this condition and deal with it properly
(by returning {\tt -1}).

\index{recursion}

The easiest way to tell that your card is not in the deck
is if there are {\em no} cards in the deck, which is the
case if {\tt high} is less than {\tt low}.  Well, there are
still cards in the deck, of course, but what I mean is that
there are no cards in the segment of the deck indicated by
{\tt low} and {\tt high}.

With that line added, the function works correctly:

\begin{verbatim}
int findBisect (const Card& card, const apvector<Card>& deck,
                int low, int high) {

  cout << low << ", " << high << endl;

  if (high < low) return -1;

  int mid = (high + low) / 2;

  if (equals (deck[mid], card)) return mid;

  if (deck[mid].isGreater (card)) {
    return findBisect (card, deck, low, mid-1);
  } else {
    return findBisect (card, deck, mid+1, high);
  }
}
\end{verbatim}
%
I added an output statement at the beginning so I could watch
the sequence of recursive calls and convince myself
that it would eventually reach the base case.  I tried out the
following code:

\begin{verbatim}
  cout << findBisect (deck, deck[23], 0, 51));
\end{verbatim}
%
And got the following output:

\begin{verbatim}
0, 51
0, 24
13, 24
19, 24
22, 24
I found the card at index = 23
\end{verbatim}
%
Then I made up a card that is not in the deck (the 15 of Diamonds),
and tried to find it.  I got the following:

\begin{verbatim}
0, 51
0, 24
13, 24
13, 17
13, 14
13, 12
I found the card at index = -1
\end{verbatim}
%
These tests don't prove that this program is correct.  In fact, no
amount of testing can prove that a program is correct.  On the other
hand, by looking at a few cases and examining the code, you might be
able to convince yourself.

\index{testing}
\index{correctness}

The number of recursive calls is fairly small, typically 6 or 7.  That
means we only had to call {\tt equals} and {\tt isGreater} 6 or 7
times, compared to up to 52 times if we did a linear search.  In
general, bisection is much faster than a linear search, especially for
large vectors.

Two common errors in recursive programs are forgetting to include a
base case and writing the recursive call so that the base case is never
reached.  Either error will cause an infinite recursion, in which case
C++ will (eventually) generate a run-time error.

\index{recursion!infinite}
\index{infinite recursion}
\index{run-time error}

\section{Decks and subdecks}
\index{deck}
\index{subdeck}

Looking at the interface to {\tt findBisect}

\begin{verbatim}
int findBisect (const Card& card, const apvector<Card>& deck,
		int low, int high) {
\end{verbatim}
%
it might make sense to treat three of the parameters, {\tt deck}, {\tt
low} and {\tt high}, as a single parameter that specifies a {\bf
subdeck}.

\index{parameter!abstract}
\index{abstract parameter}

This kind of thing is quite common, and I sometimes think of it as an
{\bf abstract parameter}.  What I mean by ``abstract,'' is something
that is not literally part of the program text, but which describes the
function of the program at a higher level.

For example, when you call a function and pass a vector and the bounds
{\tt low} and {\tt high}, there is nothing that prevents the called
function from accessing parts of the vector that are out of bounds.  So
you are not literally sending a subset of the deck; you are really
sending the whole deck.  But as long as the recipient plays by the
rules, it makes sense to think of it, abstractly, as a subdeck.

There is one other example of this kind of abstraction that you might
have noticed in Section~\ref{objectops}, when I referred to an
``empty'' data structure.  The reason I put ``empty'' in quotation
marks was to suggest that it is not literally accurate.  All variables
have values all the time.  When you create them, they are given
default values.  So there is no such thing as an empty object.

But if the program guarantees that the current value of a variable is
never read before it is written, then the current value is irrelevant.
Abstractly, it makes sense to think of such a variable as ``empty.''

This kind of thinking, in which a program comes to take on meaning
beyond what is literally encoded, is a very important part of thinking
like a computer scientist.  Sometimes, the word ``abstract'' gets used
so often and in so many contexts that it is hard to interpret.
Nevertheless, abstraction is a central idea in computer science (as
well as many other fields).

\index{abstraction}

A more general definition of ``abstraction'' is ``The process of
modeling a complex system with a simplified description in order to
suppress unnecessary details while capturing relevant behavior.''

\section{Glossary}

\begin{description}

\item[encode:]  To represent one set of values using another
set of values, by constructing a mapping between them.

\item[abstract parameter:]  A set of parameters that act together
as a single parameter.

\index{encode}
\index{abstract parameter}

\end{description}


